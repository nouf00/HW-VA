var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Endpoint_instances, _Endpoint_getDefaultCorsHeaders, _Endpoint_parseOutput, _Endpoint_runMiddlewares, _Endpoint_parseAndRunHandler, _Endpoint_handleResult;
import { z } from "zod";
import { IOSchemaError, ResultHandlerError } from "./errors.js";
import { getActualMethod, getInput, hasTopLevelTransformingEffect, makeErrorFromAnything, } from "./common-helpers.js";
import { combineContainers } from "./logical-container.js";
import { lastResortHandler } from "./result-handler.js";
export class AbstractEndpoint {
}
export class Endpoint extends AbstractEndpoint {
    constructor({ middlewares, inputSchema, outputSchema, handler, resultHandler, description, shortDescription, mimeTypes, ...rest }) {
        super();
        _Endpoint_instances.add(this);
        this.methods = [];
        this.middlewares = [];
        [
            { name: "input schema", schema: inputSchema },
            { name: "output schema", schema: outputSchema },
        ].forEach(({ name, schema }) => {
            if (hasTopLevelTransformingEffect(schema)) {
                throw new IOSchemaError(`Using transformations on the top level of endpoint ${name} is not allowed.`);
            }
        });
        this.middlewares = middlewares;
        this.inputSchema = inputSchema;
        this.mimeTypes = mimeTypes;
        this.outputSchema = outputSchema;
        this.handler = handler;
        this.resultHandler = resultHandler;
        this.descriptions = { long: description, short: shortDescription };
        this.scopes = [];
        this.tags = [];
        if ("scopes" in rest && rest.scopes) {
            this.scopes.push(...rest.scopes);
        }
        if ("scope" in rest && rest.scope) {
            this.scopes.push(rest.scope);
        }
        if ("tags" in rest && rest.tags) {
            this.tags.push(...rest.tags);
        }
        if ("tag" in rest && rest.tag) {
            this.tags.push(rest.tag);
        }
        if ("methods" in rest) {
            this.methods = rest.methods;
        }
        else {
            this.methods = [rest.method];
        }
    }
    getDescription(variant) {
        return this.descriptions[variant];
    }
    getMethods() {
        return this.methods;
    }
    getInputSchema() {
        return this.inputSchema;
    }
    getOutputSchema() {
        return this.outputSchema;
    }
    getPositiveResponseSchema() {
        return this.resultHandler.getPositiveResponse(this.outputSchema).schema;
    }
    getNegativeResponseSchema() {
        return this.resultHandler.getNegativeResponse().schema;
    }
    getInputMimeTypes() {
        return this.mimeTypes;
    }
    getPositiveMimeTypes() {
        return this.resultHandler.getPositiveResponse(this.outputSchema).mimeTypes;
    }
    getNegativeMimeTypes() {
        return this.resultHandler.getNegativeResponse().mimeTypes;
    }
    getSecurity() {
        return this.middlewares.reduce((acc, middleware) => middleware.security ? combineContainers(acc, middleware.security) : acc, { and: [] });
    }
    getScopes() {
        return this.scopes;
    }
    getTags() {
        return this.tags;
    }
    async execute({ request, response, logger, config, }) {
        const method = getActualMethod(request);
        let output;
        let error = null;
        if (config.cors) {
            let headers = __classPrivateFieldGet(this, _Endpoint_instances, "m", _Endpoint_getDefaultCorsHeaders).call(this);
            if (typeof config.cors === "function") {
                headers = await config.cors({
                    request,
                    logger,
                    endpoint: this,
                    defaultHeaders: headers,
                });
            }
            for (const key in headers) {
                response.set(key, headers[key]);
            }
        }
        const input = getInput(request, config.inputSources);
        try {
            const { options, isStreamClosed } = await __classPrivateFieldGet(this, _Endpoint_instances, "m", _Endpoint_runMiddlewares).call(this, {
                method,
                input,
                request,
                response,
                logger,
            });
            if (isStreamClosed) {
                return;
            }
            if (method === "options") {
                response.status(200).end();
                return;
            }
            output = await __classPrivateFieldGet(this, _Endpoint_instances, "m", _Endpoint_parseOutput).call(this, await __classPrivateFieldGet(this, _Endpoint_instances, "m", _Endpoint_parseAndRunHandler).call(this, { input, options, logger }));
        }
        catch (e) {
            error = makeErrorFromAnything(e);
        }
        await __classPrivateFieldGet(this, _Endpoint_instances, "m", _Endpoint_handleResult).call(this, {
            input,
            output,
            request,
            response,
            error,
            logger,
        });
    }
}
_Endpoint_instances = new WeakSet(), _Endpoint_getDefaultCorsHeaders = function _Endpoint_getDefaultCorsHeaders() {
    const accessMethods = this.methods
        .concat("options")
        .join(", ")
        .toUpperCase();
    return {
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Methods": accessMethods,
        "Access-Control-Allow-Headers": "content-type",
    };
}, _Endpoint_parseOutput = async function _Endpoint_parseOutput(output) {
    try {
        return await this.outputSchema.parseAsync(output);
    }
    catch (e) {
        if (e instanceof z.ZodError) {
            throw new z.ZodError([
                {
                    message: "Invalid format",
                    code: "custom",
                    path: ["output"],
                },
                ...e.issues.map((issue) => ({
                    ...issue,
                    path: issue.path.length === 0 ? ["output"] : issue.path,
                })),
            ]);
        }
        throw makeErrorFromAnything(e);
    }
}, _Endpoint_runMiddlewares = async function _Endpoint_runMiddlewares({ method, input, request, response, logger, }) {
    const options = {};
    let isStreamClosed = false;
    for (const def of this.middlewares) {
        if (method === "options" && def.type === "proprietary") {
            continue;
        }
        Object.assign(options, await def.middleware({
            input: await def.input.parseAsync(input),
            options,
            request,
            response,
            logger,
        }));
        isStreamClosed = "writableEnded" in response && response.writableEnded;
        if (isStreamClosed) {
            logger.warn(`The middleware ${def.middleware.name} has closed the stream. Accumulated options:`, options);
            break;
        }
    }
    return { options, isStreamClosed };
}, _Endpoint_parseAndRunHandler = async function _Endpoint_parseAndRunHandler({ input, options, logger, }) {
    return this.handler({
        // final input types transformations for handler
        input: (await this.inputSchema.parseAsync(input)),
        options,
        logger,
    });
}, _Endpoint_handleResult = async function _Endpoint_handleResult({ error, request, response, logger, input, output, }) {
    try {
        await this.resultHandler.handler({
            error,
            output,
            request,
            response,
            logger,
            input,
        });
    }
    catch (e) {
        lastResortHandler({
            logger,
            response,
            error: new ResultHandlerError(makeErrorFromAnything(e).message, error),
        });
    }
};
//# sourceMappingURL=endpoint.js.map