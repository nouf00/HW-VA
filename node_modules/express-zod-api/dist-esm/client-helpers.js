import ts from "typescript";
export const f = ts.factory;
export const exportModifier = [f.createModifier(ts.SyntaxKind.ExportKeyword)];
export const publicReadonlyModifier = [
    f.createModifier(ts.SyntaxKind.PublicKeyword),
    f.createModifier(ts.SyntaxKind.ReadonlyKeyword),
];
export const protectedReadonlyModifier = [
    f.createModifier(ts.SyntaxKind.ProtectedKeyword),
    f.createModifier(ts.SyntaxKind.ReadonlyKeyword),
];
const emptyPrefix = f.createTemplateHead("");
const emptyEnding = f.createTemplateTail("");
const spacingSuffix = f.createTemplateMiddle(" ");
export const makeTemplate = (names) => f.createTemplateLiteralType(emptyPrefix, names.map((name, index) => f.createTemplateLiteralTypeSpan(f.createTypeReferenceNode(name), index === names.length - 1 ? emptyEnding : spacingSuffix)));
export const parametricIndexNode = makeTemplate(["M", "P"]);
export const makeParam = (name, type, mod) => f.createParameterDeclaration(undefined, mod, undefined, name, undefined, type);
export const makeParams = (params, mod) => Object.keys(params).reduce((acc, name) => acc.concat(makeParam(name, params[name], mod)), []);
export const makeRecord = (key, value) => f.createExpressionWithTypeArguments(f.createIdentifier("Record"), [
    typeof key === "number"
        ? f.createKeywordTypeNode(key)
        : f.createTypeReferenceNode(key),
    f.createKeywordTypeNode(value),
]);
export const makeEmptyInitializingConstructor = (params) => f.createConstructorDeclaration(undefined, undefined, params, f.createBlock([]));
export const makeQuotedProp = (name, ref) => f.createPropertySignature(undefined, `"${name}"`, undefined, f.createTypeReferenceNode(ref));
export const makeConst = (name, value) => f.createVariableDeclarationList([f.createVariableDeclaration(name, undefined, undefined, value)], ts.NodeFlags.Const);
export const makePublicLiteralType = (name, literals) => f.createTypeAliasDeclaration(undefined, exportModifier, name, undefined, f.createUnionTypeNode(literals.map((option) => f.createLiteralTypeNode(f.createStringLiteral(option)))));
export const makePublicType = (name, value) => f.createTypeAliasDeclaration(undefined, exportModifier, name, undefined, value);
export const makePublicReadonlyProp = (name, type, exp) => f.createPropertyDeclaration(undefined, publicReadonlyModifier, name, undefined, type, exp);
export const makePublicClass = (name, constructor, props = []) => f.createClassDeclaration(undefined, exportModifier, name, undefined, undefined, [constructor, ...props]);
export const makeIndexedPromise = (type, index) => f.createTypeReferenceNode("Promise", [
    f.createIndexedAccessTypeNode(f.createTypeReferenceNode(type), index),
]);
export const makeAnyPromise = () => f.createTypeReferenceNode("Promise", [
    f.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword),
]);
export const makePublicExtendedInterface = (name, extender, props) => f.createInterfaceDeclaration(undefined, exportModifier, name, undefined, extender, props);
export const makeTypeParams = (params) => Object.keys(params).reduce((acc, name) => acc.concat(f.createTypeParameterDeclaration([], name, f.createTypeReferenceNode(params[name]))), []);
export const makeImplementationCallFn = (params, args) => f.createArrowFunction(undefined, undefined, params.map((key) => makeParam(key)), undefined, undefined, f.createCallExpression(f.createPropertyAccessExpression(f.createThis(), "implementation"), undefined, args));
export const makeObjectKeysReducer = (obj, exp, initial) => f.createCallExpression(f.createPropertyAccessExpression(f.createCallExpression(f.createPropertyAccessExpression(f.createIdentifier("Object"), "keys"), undefined, [f.createIdentifier(obj)]), "reduce"), undefined, [
    f.createArrowFunction(undefined, undefined, makeParams({ acc: undefined, key: undefined }), undefined, undefined, exp),
    initial,
]);
export const cleanId = (path, method, suffix) => {
    return [method]
        .concat(path.split("/"))
        .concat(suffix)
        .map((entry) => entry.replace(/[^A-Z0-9]/i, ""))
        .map((entry) => entry.slice(0, 1).toUpperCase() + entry.slice(1).toLowerCase())
        .join("");
};
//# sourceMappingURL=client-helpers.js.map