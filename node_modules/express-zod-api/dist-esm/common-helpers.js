import { HttpError } from "http-errors";
import { z } from "zod";
import { loggerLevels, } from "./config-type.js";
import { getMeta } from "./metadata.js";
import { mimeMultipart } from "./mime.js";
import { ZodUpload } from "./upload-schema.js";
/** @see https://expressjs.com/en/guide/routing.html */
export const routePathParamsRegex = /:([A-Za-z0-9_]+)/g;
function areFilesAvailable(request) {
    const contentType = request.header("content-type") || "";
    const isMultipart = contentType.slice(0, mimeMultipart.length).toLowerCase() === mimeMultipart;
    return "files" in request && isMultipart;
}
export const defaultInputSources = {
    get: ["query", "params"],
    post: ["body", "params", "files"],
    put: ["body", "params"],
    patch: ["body", "params"],
    delete: ["body", "query", "params"],
};
const fallbackInputSource = defaultInputSources.delete;
export const getActualMethod = (request) => request.method.toLowerCase();
export function getInput(request, inputAssignment) {
    const method = getActualMethod(request);
    if (method === "options") {
        return {};
    }
    let props = fallbackInputSource;
    if (method in defaultInputSources) {
        props = defaultInputSources[method];
    }
    if (inputAssignment && method in inputAssignment) {
        props = inputAssignment[method] || props;
    }
    return props
        .filter((prop) => (prop === "files" ? areFilesAvailable(request) : true))
        .reduce((carry, prop) => ({
        ...carry,
        ...request[prop],
    }), {});
}
export function isLoggerConfig(logger) {
    return (typeof logger === "object" &&
        "level" in logger &&
        "color" in logger &&
        Object.keys(loggerLevels).includes(logger.level) &&
        typeof logger.color === "boolean");
}
export function isValidDate(date) {
    return !isNaN(date.getTime());
}
export function makeErrorFromAnything(subject) {
    return subject instanceof Error
        ? subject
        : new Error(typeof subject === "symbol" ? subject.toString() : `${subject}`);
}
export function getMessageFromError(error) {
    if (error instanceof z.ZodError) {
        return error.issues
            .map(({ path, message }) => (path.length ? [path.join("/")] : []).concat(message).join(": "))
            .join("; ");
    }
    return error.message;
}
export function getStatusCodeFromError(error) {
    if (error instanceof HttpError) {
        return error.statusCode;
    }
    if (error instanceof z.ZodError) {
        return 400;
    }
    return 500;
}
export const getExamples = (schema, parseToOutput) => {
    const examples = getMeta(schema, "examples");
    if (examples === undefined) {
        return [];
    }
    return examples.reduce((carry, example) => {
        const parsedExample = schema.safeParse(example);
        return carry.concat(parsedExample.success
            ? parseToOutput
                ? parsedExample.data
                : example
            : []);
    }, []);
};
export const combinations = (a, b) => {
    if (a.length === 0) {
        return { type: "single", value: b };
    }
    if (b.length === 0) {
        return { type: "single", value: a };
    }
    const result = [];
    for (const itemA of a) {
        for (const itemB of b) {
            result.push([itemA, itemB]);
        }
    }
    return { type: "tuple", value: result };
};
export function getRoutePathParams(path) {
    const match = path.match(routePathParamsRegex);
    if (!match) {
        return [];
    }
    return match.map((param) => param.slice(1));
}
const reduceBool = (arr) => arr.reduce((carry, bool) => carry || bool, false);
export function hasTopLevelTransformingEffect(schema) {
    if (schema instanceof z.ZodEffects) {
        if (schema._def.effect.type !== "refinement") {
            return true;
        }
    }
    if (schema instanceof z.ZodUnion) {
        return reduceBool(schema.options.map(hasTopLevelTransformingEffect));
    }
    if (schema instanceof z.ZodIntersection) {
        return reduceBool([schema._def.left, schema._def.right].map(hasTopLevelTransformingEffect));
    }
    return false; // ZodObject left
}
export function hasUpload(schema) {
    if (schema instanceof ZodUpload) {
        return true;
    }
    if (schema instanceof z.ZodObject) {
        return reduceBool(Object.values(schema.shape).map(hasUpload));
    }
    if (schema instanceof z.ZodUnion) {
        return reduceBool(schema.options.map(hasUpload));
    }
    if (schema instanceof z.ZodIntersection) {
        return reduceBool([schema._def.left, schema._def.right].map(hasUpload));
    }
    if (schema instanceof z.ZodOptional || schema instanceof z.ZodNullable) {
        return hasUpload(schema.unwrap());
    }
    if (schema instanceof z.ZodEffects || schema instanceof z.ZodTransformer) {
        return hasUpload(schema._def.schema);
    }
    if (schema instanceof z.ZodRecord) {
        return hasUpload(schema._def.valueType);
    }
    if (schema instanceof z.ZodArray) {
        return hasUpload(schema._def.type);
    }
    if (schema instanceof z.ZodDefault) {
        return hasUpload(schema._def.innerType);
    }
    return false;
}
// the copy of the private Zod errorUtil.errToObj
export const errToObj = (message) => typeof message === "string" ? { message } : message || {};
//# sourceMappingURL=common-helpers.js.map