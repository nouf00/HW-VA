import { omit } from "ramda";
import { z } from "zod";
import { getExamples, getRoutePathParams, hasTopLevelTransformingEffect, routePathParamsRegex, } from "./common-helpers.js";
import { isoDateRegex } from "./date-in-schema.js";
import { OpenAPIError } from "./errors.js";
import { andToOr, mapLogicalContainer, } from "./logical-container.js";
import { copyMeta } from "./metadata.js";
const shortDescriptionLimit = 50;
const isoDateDocumentationUrl = "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString";
/* eslint-disable @typescript-eslint/no-use-before-define */
export const reformatParamsInPath = (path) => path.replace(routePathParamsRegex, (param) => `{${param.slice(1)}}`);
export const depictDefault = ({ schema: { _def: { innerType, defaultValue }, }, initial, isResponse, }) => ({
    ...initial,
    ...depictSchema({ schema: innerType, initial, isResponse }),
    default: defaultValue(),
});
export const depictAny = ({ initial }) => ({
    ...initial,
    format: "any",
});
export const depictUpload = ({ initial, isResponse, }) => {
    if (isResponse) {
        throw new OpenAPIError("Please use z.upload() only for input.");
    }
    return {
        ...initial,
        type: "string",
        format: "binary",
    };
};
export const depictFile = ({ schema: { isBinary, isBase64 }, initial, isResponse, }) => {
    if (!isResponse) {
        throw new OpenAPIError("Please use z.file() only within ResultHandler.");
    }
    return {
        ...initial,
        type: "string",
        format: isBinary ? "binary" : isBase64 ? "byte" : "file",
    };
};
export const depictUnion = ({ schema: { options }, initial, isResponse }) => ({
    ...initial,
    oneOf: options.map((option) => depictSchema({ schema: option, isResponse })),
});
export const depictDiscriminatedUnion = ({ schema: { options, discriminator }, initial, isResponse }) => {
    return {
        ...initial,
        discriminator: {
            propertyName: discriminator,
        },
        oneOf: Array.from(options.values()).map((option) => depictSchema({ schema: option, isResponse })),
    };
};
export const depictIntersection = ({ schema: { _def: { left, right }, }, initial, isResponse, }) => ({
    ...initial,
    allOf: [
        depictSchema({ schema: left, isResponse }),
        depictSchema({ schema: right, isResponse }),
    ],
});
export const depictOptionalOrNullable = ({ schema, initial, isResponse }) => ({
    ...initial,
    ...depictSchema({ schema: schema.unwrap(), isResponse }),
});
export const depictEnum = ({ schema: { _def: { values }, }, initial, }) => ({
    ...initial,
    type: typeof Object.values(values)[0],
    enum: Object.values(values),
});
export const depictLiteral = ({ schema: { _def: { value }, }, initial, }) => ({
    ...initial,
    type: typeof value,
    enum: [value],
});
export const depictObject = ({ schema, initial, isResponse, }) => ({
    ...initial,
    type: "object",
    properties: depictObjectProperties({ schema, isResponse }),
    required: Object.keys(schema.shape).filter((key) => !schema.shape[key].isOptional()),
});
/** @see https://swagger.io/docs/specification/data-models/data-types/ */
export const depictNull = ({ initial }) => ({
    ...initial,
    type: "string",
    nullable: true,
    format: "null",
});
export const depictDateIn = ({ initial, isResponse, }) => {
    if (isResponse) {
        throw new OpenAPIError("Please use z.dateOut() for output.");
    }
    return {
        description: "YYYY-MM-DDTHH:mm:ss.sssZ",
        ...initial,
        type: "string",
        format: "date-time",
        pattern: isoDateRegex.source,
        externalDocs: {
            url: isoDateDocumentationUrl,
        },
    };
};
export const depictDateOut = ({ initial, isResponse, }) => {
    if (!isResponse) {
        throw new OpenAPIError("Please use z.dateIn() for input.");
    }
    return {
        description: "YYYY-MM-DDTHH:mm:ss.sssZ",
        ...initial,
        type: "string",
        format: "date-time",
        externalDocs: {
            url: isoDateDocumentationUrl,
        },
    };
};
/** @throws OpenAPIError */
export const depictZodDate = ({ isResponse }) => {
    throw new OpenAPIError(`Using z.date() within ${isResponse ? "output" : "input"} schema is forbidden. Please use z.date${isResponse ? "Out" : "In"}() instead. Check out the documentation for details.`);
};
export const depictBoolean = ({ initial }) => ({
    ...initial,
    type: "boolean",
});
export const depictBigInt = ({ initial }) => ({
    ...initial,
    type: "integer",
    format: "bigint",
});
export const depictRecord = ({ schema: { _def: def }, initial, isResponse, }) => {
    if (def.keyType instanceof z.ZodEnum ||
        def.keyType instanceof z.ZodNativeEnum) {
        const keys = Object.values(def.keyType._def.values);
        const shape = keys.reduce((carry, key) => ({
            ...carry,
            [key]: def.valueType,
        }), {});
        return {
            ...initial,
            type: "object",
            properties: depictObjectProperties({
                schema: z.object(shape),
                isResponse,
            }),
            required: keys,
        };
    }
    if (def.keyType instanceof z.ZodLiteral) {
        return {
            ...initial,
            type: "object",
            properties: depictObjectProperties({
                schema: z.object({
                    [def.keyType._def.value]: def.valueType,
                }),
                isResponse,
            }),
            required: [def.keyType._def.value],
        };
    }
    if (def.keyType instanceof z.ZodUnion) {
        const areOptionsLiteral = def.keyType.options.reduce((carry, option) => carry && option instanceof z.ZodLiteral, true);
        if (areOptionsLiteral) {
            const shape = def.keyType.options.reduce((carry, option) => ({
                ...carry,
                [option.value]: def.valueType,
            }), {});
            return {
                ...initial,
                type: "object",
                properties: depictObjectProperties({
                    schema: z.object(shape),
                    isResponse,
                }),
                required: def.keyType.options.map((option) => option.value),
            };
        }
    }
    return {
        ...initial,
        type: "object",
        additionalProperties: depictSchema({ schema: def.valueType, isResponse }),
    };
};
export const depictArray = ({ schema: { _def: def }, initial, isResponse, }) => ({
    ...initial,
    type: "array",
    items: depictSchema({ schema: def.type, isResponse }),
    ...(def.minLength ? { minItems: def.minLength.value } : {}),
    ...(def.maxLength ? { maxItems: def.maxLength.value } : {}),
});
/** @todo improve it when OpenAPI 3.1.0 will be released */
export const depictTuple = ({ schema: { items }, initial, isResponse, }) => {
    const types = items.map((item) => depictSchema({ schema: item, isResponse }));
    return {
        ...initial,
        type: "array",
        minItems: types.length,
        maxItems: types.length,
        items: {
            oneOf: types,
            format: "tuple",
            ...(types.length === 0
                ? {}
                : {
                    description: types
                        .map((item, index) => `${index}: ${item.type}`)
                        .join(", "),
                }),
        },
    };
};
export const depictString = ({ schema: { _def: { checks }, }, initial, }) => {
    const isEmail = checks.find(({ kind }) => kind === "email") !== undefined;
    const isUrl = checks.find(({ kind }) => kind === "url") !== undefined;
    const isUUID = checks.find(({ kind }) => kind === "uuid") !== undefined;
    const isCUID = checks.find(({ kind }) => kind === "cuid") !== undefined;
    const minLengthCheck = checks.find(({ kind }) => kind === "min");
    const maxLengthCheck = checks.find(({ kind }) => kind === "max");
    const regexCheck = checks.find(({ kind }) => kind === "regex");
    return {
        ...initial,
        type: "string",
        ...(isEmail ? { format: "email" } : {}),
        ...(isUrl ? { format: "url" } : {}),
        ...(isUUID ? { format: "uuid" } : {}),
        ...(isCUID ? { format: "cuid" } : {}),
        ...(minLengthCheck ? { minLength: minLengthCheck.value } : {}),
        ...(maxLengthCheck ? { maxLength: maxLengthCheck.value } : {}),
        ...(regexCheck
            ? { pattern: `/${regexCheck.regex.source}/${regexCheck.regex.flags}` }
            : {}),
    };
};
/** @todo support exclusive min/max as numbers in case of OpenAPI v3.1.x */
export const depictNumber = ({ schema, initial, }) => {
    const minCheck = schema._def.checks.find(({ kind }) => kind === "min");
    const isMinInclusive = minCheck ? minCheck.inclusive : true;
    const maxCheck = schema._def.checks.find(({ kind }) => kind === "max");
    const isMaxInclusive = maxCheck ? maxCheck.inclusive : true;
    return {
        ...initial,
        type: schema.isInt ? "integer" : "number",
        format: schema.isInt ? "int64" : "double",
        minimum: schema.minValue === null
            ? schema.isInt
                ? Number.MIN_SAFE_INTEGER
                : Number.MIN_VALUE
            : schema.minValue,
        exclusiveMinimum: !isMinInclusive,
        maximum: schema.maxValue === null
            ? schema.isInt
                ? Number.MAX_SAFE_INTEGER
                : Number.MAX_VALUE
            : schema.maxValue,
        exclusiveMaximum: !isMaxInclusive,
    };
};
export const depictObjectProperties = ({ schema: { shape }, isResponse, }) => {
    return Object.keys(shape).reduce((carry, key) => ({
        ...carry,
        [key]: depictSchema({ schema: shape[key], isResponse }),
    }), {});
};
export const depictEffect = ({ schema, initial, isResponse, }) => {
    const input = depictSchema({ schema: schema._def.schema, isResponse });
    const effect = schema._def.effect;
    if (isResponse && effect && effect.type === "transform") {
        let output = "undefined";
        try {
            output = typeof effect.transform(["integer", "number"].includes(`${input.type}`)
                ? 0
                : "string" === input.type
                    ? ""
                    : "boolean" === input.type
                        ? false
                        : "object" === input.type
                            ? {}
                            : "null" === input.type
                                ? null
                                : "array" === input.type
                                    ? []
                                    : undefined, { addIssue: () => { }, path: [] });
        }
        catch (e) {
            /**/
        }
        return {
            ...initial,
            ...input,
            ...(["number", "string", "boolean"].includes(output)
                ? {
                    type: output,
                }
                : {}),
        };
    }
    if (!isResponse && effect && effect.type === "preprocess") {
        const { type: inputType, ...rest } = input;
        return {
            ...initial,
            ...rest,
            format: `${rest.format || inputType} (preprocessed)`,
        };
    }
    return { ...initial, ...input };
};
export const depictZodBranded = ({ schema, initial, isResponse }) => depictSchema({ schema: schema.unwrap(), isResponse, initial });
export const depictIOExamples = (schema, isResponse, omitProps = []) => {
    const examples = getExamples(schema, isResponse);
    if (examples.length === 0) {
        return {};
    }
    return {
        examples: examples.reduce((carry, example, index) => ({
            ...carry,
            [`example${index + 1}`]: {
                value: omit(omitProps, example),
            },
        }), {}),
    };
};
export const depictIOParamExamples = (schema, isResponse, param) => {
    const examples = getExamples(schema, isResponse);
    if (examples.length === 0) {
        return {};
    }
    return {
        examples: examples.reduce((carry, example, index) => param in example
            ? {
                ...carry,
                [`example${index + 1}`]: {
                    value: example[param],
                },
            }
            : carry, {}),
    };
};
export function extractObjectSchema(subject) {
    if (subject instanceof z.ZodObject) {
        return subject;
    }
    let objectSchema;
    if (subject instanceof z.ZodUnion ||
        subject instanceof z.ZodDiscriminatedUnion) {
        objectSchema = Array.from(subject.options.values())
            .map((option) => extractObjectSchema(option))
            .reduce((acc, option) => acc.merge(option.partial()), z.object({}));
    }
    else if (subject instanceof z.ZodEffects) {
        if (hasTopLevelTransformingEffect(subject)) {
            throw new OpenAPIError("Using transformations on the top level of input schema is not allowed.");
        }
        objectSchema = extractObjectSchema(subject._def.schema); // object refinement
    }
    else {
        // intersection
        objectSchema = extractObjectSchema(subject._def.left).merge(extractObjectSchema(subject._def.right));
    }
    return copyMeta(subject, objectSchema);
}
export const depictRequestParams = ({ path, method, endpoint, inputSources, }) => {
    const schema = endpoint.getInputSchema();
    const shape = extractObjectSchema(schema).shape;
    const pathParams = getRoutePathParams(path);
    const isQueryEnabled = inputSources.includes("query");
    const isParamsEnabled = inputSources.includes("params");
    const isPathParam = (name) => isParamsEnabled && pathParams.includes(name);
    return Object.keys(shape)
        .filter((name) => isQueryEnabled || isPathParam(name))
        .map((name) => ({
        name,
        in: isPathParam(name) ? "path" : "query",
        required: !shape[name].isOptional(),
        schema: {
            description: `${method.toUpperCase()} ${path} parameter`,
            ...depictSchema({ schema: shape[name], isResponse: false }),
        },
        ...depictIOParamExamples(schema, false, name),
    }));
};
const depictHelpers = {
    ZodString: depictString,
    ZodNumber: depictNumber,
    ZodBigInt: depictBigInt,
    ZodBoolean: depictBoolean,
    ZodDateIn: depictDateIn,
    ZodDateOut: depictDateOut,
    ZodNull: depictNull,
    ZodArray: depictArray,
    ZodTuple: depictTuple,
    ZodRecord: depictRecord,
    ZodObject: depictObject,
    ZodLiteral: depictLiteral,
    ZodIntersection: depictIntersection,
    ZodUnion: depictUnion,
    ZodFile: depictFile,
    ZodUpload: depictUpload,
    ZodAny: depictAny,
    ZodDefault: depictDefault,
    ZodEnum: depictEnum,
    ZodNativeEnum: depictEnum,
    ZodEffects: depictEffect,
    ZodOptional: depictOptionalOrNullable,
    ZodNullable: depictOptionalOrNullable,
    ZodDiscriminatedUnion: depictDiscriminatedUnion,
    ZodBranded: depictZodBranded,
    ZodDate: depictZodDate,
};
export const depictSchema = ({ schema, isResponse, }) => {
    const initial = {};
    if (schema.isNullable()) {
        initial.nullable = true;
    }
    if (schema.description) {
        initial.description = `${schema.description}`;
    }
    const examples = getExamples(schema, isResponse);
    if (examples.length > 0) {
        initial.example = examples[0];
    }
    const nextHelper = "typeName" in schema._def
        ? depictHelpers[schema._def.typeName]
        : null;
    if (!nextHelper) {
        throw new OpenAPIError(`Zod type ${schema.constructor.name} is unsupported`);
    }
    return nextHelper({ schema, initial, isResponse });
};
export const excludeParamsFromDepiction = (depicted, pathParams) => {
    const properties = depicted.properties
        ? omit(pathParams, depicted.properties)
        : undefined;
    const example = depicted.example
        ? omit(pathParams, depicted.example)
        : undefined;
    const required = depicted.required
        ? depicted.required.filter((name) => !pathParams.includes(name))
        : undefined;
    const allOf = depicted.allOf
        ? depicted.allOf.map((entry) => excludeParamsFromDepiction(entry, pathParams))
        : undefined;
    const oneOf = depicted.oneOf
        ? depicted.oneOf.map((entry) => excludeParamsFromDepiction(entry, pathParams))
        : undefined;
    return omit(Object.entries({ properties, required, example, allOf, oneOf })
        .filter(([{}, value]) => value === undefined)
        .map(([key]) => key), {
        ...depicted,
        properties,
        required,
        example,
        allOf,
        oneOf,
    });
};
export const excludeExampleFromDepiction = (depicted) => omit(["example"], depicted);
export const depictResponse = ({ method, path, description, endpoint, isPositive, }) => {
    const schema = isPositive
        ? endpoint.getPositiveResponseSchema()
        : endpoint.getNegativeResponseSchema();
    const mimeTypes = isPositive
        ? endpoint.getPositiveMimeTypes()
        : endpoint.getNegativeMimeTypes();
    const depictedSchema = excludeExampleFromDepiction(depictSchema({
        schema,
        isResponse: true,
    }));
    const examples = depictIOExamples(schema, true);
    return {
        description: `${method.toUpperCase()} ${path} ${description}`,
        content: mimeTypes.reduce((carry, mimeType) => ({
            ...carry,
            [mimeType]: {
                schema: depictedSchema,
                ...examples,
            },
        }), {}),
    };
};
const depictBasicSecurity = ({}) => ({
    type: "http",
    scheme: "basic",
});
const depictBearerSecurity = ({ format: bearerFormat, }) => ({
    type: "http",
    scheme: "bearer",
    ...(bearerFormat ? { bearerFormat } : {}),
});
// @todo add description on actual input placement
const depictInputSecurity = ({ name }) => ({
    type: "apiKey",
    in: "query",
    name,
});
const depictHeaderSecurity = ({ name }) => ({
    type: "apiKey",
    in: "header",
    name,
});
const depictCookieSecurity = ({ name }) => ({
    type: "apiKey",
    in: "cookie",
    name,
});
const depictOpenIdSecurity = ({ url: openIdConnectUrl, }) => ({
    type: "openIdConnect",
    openIdConnectUrl,
});
const depictOAuth2Security = ({ flows = {} }) => ({
    type: "oauth2",
    flows: Object.keys(flows).reduce((acc, key) => {
        const flow = flows[key];
        if (!flow) {
            return acc;
        }
        const { scopes = {}, ...rest } = flow;
        return { ...acc, [key]: { ...rest, scopes } };
    }, {}),
});
export const depictSecurity = (container) => {
    const methods = {
        basic: depictBasicSecurity,
        bearer: depictBearerSecurity,
        input: depictInputSecurity,
        header: depictHeaderSecurity,
        cookie: depictCookieSecurity,
        openid: depictOpenIdSecurity,
        oauth2: depictOAuth2Security,
    };
    return mapLogicalContainer(container, (security) => methods[security.type](security));
};
export const depictSecurityRefs = (container) => {
    if (typeof container === "object") {
        if ("or" in container) {
            return container.or.map((entry) => ("and" in entry
                ? entry.and
                : [entry]).reduce((agg, { name, scopes }) => ({
                ...agg,
                [name]: scopes,
            }), {}));
        }
        if ("and" in container) {
            return depictSecurityRefs(andToOr(container));
        }
    }
    return depictSecurityRefs({ or: [container] });
};
export const depictRequest = ({ method, path, endpoint, }) => {
    const pathParams = getRoutePathParams(path);
    const bodyDepiction = excludeExampleFromDepiction(excludeParamsFromDepiction(depictSchema({
        schema: endpoint.getInputSchema(),
        isResponse: false,
    }), pathParams));
    const bodyExamples = depictIOExamples(endpoint.getInputSchema(), false, pathParams);
    return {
        content: endpoint.getInputMimeTypes().reduce((carry, mimeType) => ({
            ...carry,
            [mimeType]: {
                schema: {
                    description: `${method.toUpperCase()} ${path} request body`,
                    ...bodyDepiction,
                },
                ...bodyExamples,
            },
        }), {}),
    };
};
export const depictTags = (tags) => Object.keys(tags).map((tag) => {
    const def = tags[tag];
    return {
        name: tag,
        description: typeof def === "string" ? def : def.description,
        ...(typeof def === "object" && def.url
            ? { externalDocs: { url: def.url } }
            : {}),
    };
});
export const ensureShortDescription = (description) => {
    if (description.length <= shortDescriptionLimit) {
        return description;
    }
    return description.slice(0, shortDescriptionLimit - 1) + "…";
};
//# sourceMappingURL=open-api-helpers.js.map