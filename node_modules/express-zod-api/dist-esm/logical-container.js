import { combinations } from "./common-helpers.js";
const isObject = (subject) => typeof subject === "object" && subject !== null;
/** @desc combines several LogicalAnds into a one */
export const flattenAnds = (subject) => ({
    and: subject.reduce((agg, item) => agg.concat(isObject(item) && "and" in item ? item.and : item), []),
});
/** @desc creates a LogicalContainer out of another one */
export const mapLogicalContainer = (container, fn) => {
    if (isObject(container)) {
        if ("and" in container) {
            return {
                and: container.and.map((entry) => isObject(entry) && "or" in entry
                    ? { or: entry.or.map(fn) }
                    : fn(entry)),
            };
        }
        if ("or" in container) {
            return {
                or: container.or.map((entry) => isObject(entry) && "and" in entry
                    ? { and: entry.and.map(fn) }
                    : fn(entry)),
            };
        }
    }
    return fn(container);
};
/** @desc converts LogicalAnd into LogicalOr */
export const andToOr = (subject) => {
    return subject.and.reduce((acc, item) => {
        const combs = combinations(acc.or, isObject(item) && "or" in item ? item.or : [item]);
        if (combs.type === "single") {
            acc.or.push(...combs.value);
        }
        else {
            acc.or = combs.value.map(flattenAnds);
        }
        return acc;
    }, {
        or: [],
    });
};
/** @desc reducer, combines two LogicalContainers */
export const combineContainers = (a, b) => {
    if (isObject(a) && isObject(b)) {
        if ("and" in a) {
            if ("and" in b) {
                return flattenAnds([a, b]);
            }
            if ("or" in b) {
                return combineContainers(andToOr(a), b);
            }
        }
        if ("or" in a) {
            if ("and" in b) {
                return combineContainers(b, a);
            }
            if ("or" in b) {
                const combs = combinations(a.or, b.or);
                return {
                    or: combs.type === "single"
                        ? combs.value
                        : combs.value.map(flattenAnds),
                };
            }
        }
    }
    return { and: [a, b] };
};
//# sourceMappingURL=logical-container.js.map