import { OpenApiBuilder, } from "openapi3-ts";
import { defaultInputSources } from "./common-helpers.js";
import { mapLogicalContainer } from "./logical-container.js";
import { depictRequest, depictRequestParams, depictResponse, depictSecurity, depictSecurityRefs, depictTags, ensureShortDescription, reformatParamsInPath, } from "./open-api-helpers.js";
import { routingCycle } from "./routing.js";
export class OpenAPI extends OpenApiBuilder {
    ensureUniqSecuritySchemaName(subject) {
        for (const name in this.rootDoc.components?.securitySchemes || {}) {
            if (JSON.stringify(subject) ===
                JSON.stringify(this.rootDoc.components?.securitySchemes?.[name])) {
                return name;
            }
        }
        this.lastSecuritySchemaIds[subject.type] =
            (this.lastSecuritySchemaIds?.[subject.type] || 0) + 1;
        return `${subject.type.toUpperCase()}_${this.lastSecuritySchemaIds[subject.type]}`;
    }
    constructor({ routing, config, title, version, serverUrl, successfulResponseDescription = "Successful response", errorResponseDescription = "Error response", hasSummaryFromDescription = true, }) {
        super();
        this.lastSecuritySchemaIds = {};
        this.addInfo({ title, version }).addServer({ url: serverUrl });
        const endpointCb = (endpoint, path, _method) => {
            const method = _method;
            const commonParams = { path, method, endpoint };
            const [shortDesc, longDesc] = ["short", "long"].map(endpoint.getDescription.bind(endpoint));
            const inputSources = config.inputSources?.[method] || defaultInputSources[method];
            const depictedParams = depictRequestParams({
                ...commonParams,
                inputSources,
            });
            const operation = {
                responses: {
                    "200": depictResponse({
                        ...commonParams,
                        description: successfulResponseDescription,
                        isPositive: true,
                    }),
                    "400": depictResponse({
                        ...commonParams,
                        description: errorResponseDescription,
                        isPositive: false,
                    }),
                },
            };
            if (longDesc) {
                operation.description = longDesc;
                if (hasSummaryFromDescription && shortDesc === undefined) {
                    operation.summary = ensureShortDescription(longDesc);
                }
            }
            if (shortDesc) {
                operation.summary = ensureShortDescription(shortDesc);
            }
            if (endpoint.getTags().length > 0) {
                operation.tags = endpoint.getTags();
            }
            if (depictedParams.length > 0) {
                operation.parameters = depictedParams;
            }
            if (inputSources.includes("body")) {
                operation.requestBody = depictRequest(commonParams);
            }
            const securityRefs = depictSecurityRefs(mapLogicalContainer(depictSecurity(endpoint.getSecurity()), (securitySchema) => {
                const name = this.ensureUniqSecuritySchemaName(securitySchema);
                const scopes = ["oauth2", "openIdConnect"].includes(securitySchema.type)
                    ? endpoint.getScopes()
                    : [];
                this.addSecurityScheme(name, securitySchema);
                return { name, scopes };
            }));
            if (securityRefs.length > 0) {
                operation.security = securityRefs;
            }
            const swaggerCompatiblePath = reformatParamsInPath(path);
            this.addPath(swaggerCompatiblePath, {
                ...(this.rootDoc.paths?.[swaggerCompatiblePath] || {}),
                [method]: operation,
            });
        };
        routingCycle({ routing, endpointCb });
        this.rootDoc.tags = config.tags ? depictTags(config.tags) : [];
    }
}
//# sourceMappingURL=open-api.js.map