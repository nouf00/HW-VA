import { combinations } from "./common-helpers.js";
import { mergeDeepRight } from "ramda";
export const metaProp = "expressZodApiMeta";
export const withMeta = (schema) => {
    const def = schema._def;
    def[metaProp] = def[metaProp] || { examples: [] };
    if (!("example" in schema)) {
        Object.defineProperties(schema, {
            example: {
                get: () => (value) => {
                    def[metaProp].examples.push(value);
                    return schema;
                },
            },
        });
    }
    return schema;
};
export const hasMeta = (schema) => {
    if (!(metaProp in schema._def)) {
        return false;
    }
    return (typeof schema._def[metaProp] === "object" && schema._def[metaProp] !== null);
};
export function getMeta(schema, meta) {
    if (!hasMeta(schema)) {
        return undefined;
    }
    const def = schema._def;
    return meta in def[metaProp] ? def[metaProp][meta] : undefined;
}
export const copyMeta = (src, dest) => {
    if (!hasMeta(src)) {
        return dest;
    }
    dest = withMeta(dest);
    const def = dest._def;
    const examplesCombinations = combinations(def[metaProp].examples, src._def[metaProp].examples);
    // general deep merge except examples
    def[metaProp] = mergeDeepRight({ ...def[metaProp], examples: [] }, { ...src._def[metaProp], examples: [] });
    if (examplesCombinations.type === "single") {
        def[metaProp].examples = examplesCombinations.value;
    }
    else {
        for (const [destExample, srcExample] of examplesCombinations.value) {
            def[metaProp].examples.push(mergeDeepRight({ ...destExample }, { ...srcExample }));
        }
    }
    return dest;
};
//# sourceMappingURL=metadata.js.map