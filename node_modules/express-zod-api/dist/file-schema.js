"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZodFile = void 0;
const zod_1 = require("zod");
const common_helpers_1 = require("./common-helpers");
const zodFileKind = "ZodFile";
const base64Regex = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
class ZodFile extends zod_1.ZodType {
    constructor() {
        super(...arguments);
        this.binary = (message) => new ZodFile({
            ...this._def,
            checks: [...this._def.checks, { kind: "binary", ...(0, common_helpers_1.errToObj)(message) }],
        });
        this.base64 = (message) => new ZodFile({
            ...this._def,
            checks: [...this._def.checks, { kind: "base64", ...(0, common_helpers_1.errToObj)(message) }],
        });
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== zod_1.ZodParsedType.string) {
            (0, zod_1.addIssueToContext)(ctx, {
                code: zod_1.ZodIssueCode.invalid_type,
                expected: zod_1.ZodParsedType.string,
                received: ctx.parsedType,
            });
            return zod_1.INVALID;
        }
        for (const check of this._def.checks) {
            if (check.kind === "base64") {
                if (!base64Regex.test(ctx.data)) {
                    (0, zod_1.addIssueToContext)(ctx, {
                        code: zod_1.ZodIssueCode.custom,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
        }
        return { status: status.value, value: ctx.data };
    }
    get isBinary() {
        return !!this._def.checks.find((check) => check.kind === "binary");
    }
    get isBase64() {
        return !!this._def.checks.find((check) => check.kind === "base64");
    }
}
exports.ZodFile = ZodFile;
ZodFile.create = () => new ZodFile({
    checks: [],
    typeName: zodFileKind,
});
//# sourceMappingURL=file-schema.js.map