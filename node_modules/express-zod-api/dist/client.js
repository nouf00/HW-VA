"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const typescript_1 = __importDefault(require("typescript"));
const zod_to_ts_1 = require("zod-to-ts");
const client_helpers_1 = require("./client-helpers");
const method_1 = require("./method");
const mime_1 = require("./mime");
const routing_1 = require("./routing");
class Client {
    constructor(routing) {
        this.agg = [];
        this.registry = {};
        this.paths = [];
        (0, routing_1.routingCycle)({
            routing,
            endpointCb: (endpoint, path, method) => {
                const inputId = (0, client_helpers_1.cleanId)(path, method, "input");
                const responseId = (0, client_helpers_1.cleanId)(path, method, "response");
                const input = (0, zod_to_ts_1.zodToTs)(endpoint.getInputSchema(), inputId, {
                    resolveNativeEnums: true,
                });
                const response = (0, zod_to_ts_1.zodToTs)(endpoint
                    .getPositiveResponseSchema()
                    .or(endpoint.getNegativeResponseSchema()), responseId, { resolveNativeEnums: true });
                const inputAlias = (0, zod_to_ts_1.createTypeAlias)(input.node, inputId);
                const responseAlias = (0, zod_to_ts_1.createTypeAlias)(response.node, responseId);
                this.agg.push(...input.store.nativeEnums, ...response.store.nativeEnums);
                this.agg.push(inputAlias);
                this.agg.push(responseAlias);
                if (method !== "options") {
                    this.paths.push(path);
                    this.registry[`${method} ${path}`] = {
                        in: inputId,
                        out: responseId,
                        isJson: endpoint.getPositiveMimeTypes().includes(mime_1.mimeJson),
                    };
                }
            },
        });
        const pathNode = (0, client_helpers_1.makePublicLiteralType)("Path", this.paths);
        const methodNode = (0, client_helpers_1.makePublicLiteralType)("Method", method_1.methods);
        const methodPathNode = (0, client_helpers_1.makePublicType)("MethodPath", (0, client_helpers_1.makeTemplate)([methodNode.name, pathNode.name]));
        const extenderClause = [
            client_helpers_1.f.createHeritageClause(typescript_1.default.SyntaxKind.ExtendsKeyword, [
                (0, client_helpers_1.makeRecord)(methodPathNode.name, typescript_1.default.SyntaxKind.AnyKeyword),
            ]),
        ];
        const inputNode = (0, client_helpers_1.makePublicExtendedInterface)("Input", extenderClause, Object.keys(this.registry).map((methodPath) => (0, client_helpers_1.makeQuotedProp)(methodPath, this.registry[methodPath].in)));
        const responseNode = (0, client_helpers_1.makePublicExtendedInterface)("Response", extenderClause, Object.keys(this.registry).map((methodPath) => (0, client_helpers_1.makeQuotedProp)(methodPath, this.registry[methodPath].out)));
        const jsonEndpointsNode = client_helpers_1.f.createVariableStatement(client_helpers_1.exportModifier, (0, client_helpers_1.makeConst)("jsonEndpoints", client_helpers_1.f.createObjectLiteralExpression(Object.keys(this.registry)
            .filter((methodPath) => this.registry[methodPath].isJson)
            .map((methodPath) => client_helpers_1.f.createPropertyAssignment(`"${methodPath}"`, client_helpers_1.f.createTrue())))));
        const providerNode = (0, client_helpers_1.makePublicType)("Provider", client_helpers_1.f.createFunctionTypeNode((0, client_helpers_1.makeTypeParams)({ M: methodNode.name, P: pathNode.name }), (0, client_helpers_1.makeParams)({
            method: client_helpers_1.f.createTypeReferenceNode("M"),
            path: client_helpers_1.f.createTypeReferenceNode("P"),
            params: client_helpers_1.f.createIndexedAccessTypeNode(client_helpers_1.f.createTypeReferenceNode(inputNode.name), client_helpers_1.parametricIndexNode),
        }), (0, client_helpers_1.makeIndexedPromise)(responseNode.name, client_helpers_1.parametricIndexNode)));
        const implementationNode = (0, client_helpers_1.makePublicType)("Implementation", client_helpers_1.f.createFunctionTypeNode(undefined, (0, client_helpers_1.makeParams)({
            method: client_helpers_1.f.createTypeReferenceNode(methodNode.name),
            path: client_helpers_1.f.createKeywordTypeNode(typescript_1.default.SyntaxKind.StringKeyword),
            params: (0, client_helpers_1.makeRecord)(typescript_1.default.SyntaxKind.StringKeyword, typescript_1.default.SyntaxKind.AnyKeyword),
        }), (0, client_helpers_1.makeAnyPromise)()));
        const keyParamExpression = client_helpers_1.f.createTemplateExpression(client_helpers_1.f.createTemplateHead(":"), [
            client_helpers_1.f.createTemplateSpan(client_helpers_1.f.createIdentifier("key"), client_helpers_1.f.createTemplateTail("")),
        ]);
        const clientNode = (0, client_helpers_1.makePublicClass)("ExpressZodAPIClient", (0, client_helpers_1.makeEmptyInitializingConstructor)([
            (0, client_helpers_1.makeParam)("implementation", client_helpers_1.f.createTypeReferenceNode(implementationNode.name), client_helpers_1.protectedReadonlyModifier),
        ]), [
            (0, client_helpers_1.makePublicReadonlyProp)("provide", client_helpers_1.f.createTypeReferenceNode(providerNode.name), (0, client_helpers_1.makeImplementationCallFn)(["method", "path", "params"], [
                client_helpers_1.f.createIdentifier("method"),
                (0, client_helpers_1.makeObjectKeysReducer)("params", client_helpers_1.f.createCallExpression(client_helpers_1.f.createPropertyAccessExpression(client_helpers_1.f.createIdentifier("acc"), "replace"), undefined, [
                    keyParamExpression,
                    client_helpers_1.f.createElementAccessExpression(client_helpers_1.f.createIdentifier("params"), client_helpers_1.f.createIdentifier("key")),
                ]), client_helpers_1.f.createIdentifier("path")),
                (0, client_helpers_1.makeObjectKeysReducer)("params", client_helpers_1.f.createConditionalExpression(client_helpers_1.f.createBinaryExpression(client_helpers_1.f.createCallExpression(client_helpers_1.f.createPropertyAccessExpression(client_helpers_1.f.createIdentifier("path"), "indexOf"), undefined, [keyParamExpression]), typescript_1.default.SyntaxKind.GreaterThanEqualsToken, client_helpers_1.f.createNumericLiteral(0)), undefined, client_helpers_1.f.createIdentifier("acc"), undefined, client_helpers_1.f.createObjectLiteralExpression([
                    client_helpers_1.f.createSpreadAssignment(client_helpers_1.f.createIdentifier("acc")),
                    client_helpers_1.f.createPropertyAssignment("[key]", // @todo is there a better way to do it?
                    client_helpers_1.f.createElementAccessExpression(client_helpers_1.f.createIdentifier("params"), client_helpers_1.f.createIdentifier("key"))),
                ])), client_helpers_1.f.createObjectLiteralExpression()),
            ])),
        ]);
        typescript_1.default.addSyntheticLeadingComment(clientNode, typescript_1.default.SyntaxKind.MultiLineCommentTrivia, "\n" +
            "export const exampleImplementation: Implementation = async (\n" +
            "  method,\n" +
            "  path,\n" +
            "  params\n" +
            ") => {\n" +
            "  const searchParams =\n" +
            '    method === "get" ? `?${new URLSearchParams(params)}` : "";\n' +
            "  const response = await fetch(`https://example.com${path}${searchParams}`, {\n" +
            "    method: method.toUpperCase(),\n" +
            "    headers:\n" +
            '      method === "get" ? undefined : { "Content-Type": "application/json" },\n' +
            '    body: method === "get" ? undefined : JSON.stringify(params),\n' +
            "  });\n" +
            "  if (`${method} ${path}` in jsonEndpoints) {\n" +
            "    return response.json();\n" +
            "  }\n" +
            "  return response.text();\n" +
            "};\n" +
            "\n" +
            "const client = new ExpressZodAPIClient(exampleImplementation);\n" +
            'client.provide("get", "/v1/user/retrieve", { id: "10" });\n', true);
        this.agg.push(pathNode, methodNode, methodPathNode, inputNode, responseNode, jsonEndpointsNode, providerNode, implementationNode, clientNode);
    }
    print(printerOptions) {
        return this.agg.map((node) => (0, zod_to_ts_1.printNode)(node, printerOptions)).join("\n\n");
    }
}
exports.Client = Client;
//# sourceMappingURL=client.js.map