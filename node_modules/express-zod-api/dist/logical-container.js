"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.combineContainers = exports.andToOr = exports.mapLogicalContainer = exports.flattenAnds = void 0;
const common_helpers_1 = require("./common-helpers");
const isObject = (subject) => typeof subject === "object" && subject !== null;
/** @desc combines several LogicalAnds into a one */
const flattenAnds = (subject) => ({
    and: subject.reduce((agg, item) => agg.concat(isObject(item) && "and" in item ? item.and : item), []),
});
exports.flattenAnds = flattenAnds;
/** @desc creates a LogicalContainer out of another one */
const mapLogicalContainer = (container, fn) => {
    if (isObject(container)) {
        if ("and" in container) {
            return {
                and: container.and.map((entry) => isObject(entry) && "or" in entry
                    ? { or: entry.or.map(fn) }
                    : fn(entry)),
            };
        }
        if ("or" in container) {
            return {
                or: container.or.map((entry) => isObject(entry) && "and" in entry
                    ? { and: entry.and.map(fn) }
                    : fn(entry)),
            };
        }
    }
    return fn(container);
};
exports.mapLogicalContainer = mapLogicalContainer;
/** @desc converts LogicalAnd into LogicalOr */
const andToOr = (subject) => {
    return subject.and.reduce((acc, item) => {
        const combs = (0, common_helpers_1.combinations)(acc.or, isObject(item) && "or" in item ? item.or : [item]);
        if (combs.type === "single") {
            acc.or.push(...combs.value);
        }
        else {
            acc.or = combs.value.map(exports.flattenAnds);
        }
        return acc;
    }, {
        or: [],
    });
};
exports.andToOr = andToOr;
/** @desc reducer, combines two LogicalContainers */
const combineContainers = (a, b) => {
    if (isObject(a) && isObject(b)) {
        if ("and" in a) {
            if ("and" in b) {
                return (0, exports.flattenAnds)([a, b]);
            }
            if ("or" in b) {
                return (0, exports.combineContainers)((0, exports.andToOr)(a), b);
            }
        }
        if ("or" in a) {
            if ("and" in b) {
                return (0, exports.combineContainers)(b, a);
            }
            if ("or" in b) {
                const combs = (0, common_helpers_1.combinations)(a.or, b.or);
                return {
                    or: combs.type === "single"
                        ? combs.value
                        : combs.value.map(exports.flattenAnds),
                };
            }
        }
    }
    return { and: [a, b] };
};
exports.combineContainers = combineContainers;
//# sourceMappingURL=logical-container.js.map