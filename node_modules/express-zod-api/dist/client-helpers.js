"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.cleanId = exports.makeObjectKeysReducer = exports.makeImplementationCallFn = exports.makeTypeParams = exports.makePublicExtendedInterface = exports.makeAnyPromise = exports.makeIndexedPromise = exports.makePublicClass = exports.makePublicReadonlyProp = exports.makePublicType = exports.makePublicLiteralType = exports.makeConst = exports.makeQuotedProp = exports.makeEmptyInitializingConstructor = exports.makeRecord = exports.makeParams = exports.makeParam = exports.parametricIndexNode = exports.makeTemplate = exports.protectedReadonlyModifier = exports.publicReadonlyModifier = exports.exportModifier = exports.f = void 0;
const typescript_1 = __importDefault(require("typescript"));
exports.f = typescript_1.default.factory;
exports.exportModifier = [exports.f.createModifier(typescript_1.default.SyntaxKind.ExportKeyword)];
exports.publicReadonlyModifier = [
    exports.f.createModifier(typescript_1.default.SyntaxKind.PublicKeyword),
    exports.f.createModifier(typescript_1.default.SyntaxKind.ReadonlyKeyword),
];
exports.protectedReadonlyModifier = [
    exports.f.createModifier(typescript_1.default.SyntaxKind.ProtectedKeyword),
    exports.f.createModifier(typescript_1.default.SyntaxKind.ReadonlyKeyword),
];
const emptyPrefix = exports.f.createTemplateHead("");
const emptyEnding = exports.f.createTemplateTail("");
const spacingSuffix = exports.f.createTemplateMiddle(" ");
const makeTemplate = (names) => exports.f.createTemplateLiteralType(emptyPrefix, names.map((name, index) => exports.f.createTemplateLiteralTypeSpan(exports.f.createTypeReferenceNode(name), index === names.length - 1 ? emptyEnding : spacingSuffix)));
exports.makeTemplate = makeTemplate;
exports.parametricIndexNode = (0, exports.makeTemplate)(["M", "P"]);
const makeParam = (name, type, mod) => exports.f.createParameterDeclaration(undefined, mod, undefined, name, undefined, type);
exports.makeParam = makeParam;
const makeParams = (params, mod) => Object.keys(params).reduce((acc, name) => acc.concat((0, exports.makeParam)(name, params[name], mod)), []);
exports.makeParams = makeParams;
const makeRecord = (key, value) => exports.f.createExpressionWithTypeArguments(exports.f.createIdentifier("Record"), [
    typeof key === "number"
        ? exports.f.createKeywordTypeNode(key)
        : exports.f.createTypeReferenceNode(key),
    exports.f.createKeywordTypeNode(value),
]);
exports.makeRecord = makeRecord;
const makeEmptyInitializingConstructor = (params) => exports.f.createConstructorDeclaration(undefined, undefined, params, exports.f.createBlock([]));
exports.makeEmptyInitializingConstructor = makeEmptyInitializingConstructor;
const makeQuotedProp = (name, ref) => exports.f.createPropertySignature(undefined, `"${name}"`, undefined, exports.f.createTypeReferenceNode(ref));
exports.makeQuotedProp = makeQuotedProp;
const makeConst = (name, value) => exports.f.createVariableDeclarationList([exports.f.createVariableDeclaration(name, undefined, undefined, value)], typescript_1.default.NodeFlags.Const);
exports.makeConst = makeConst;
const makePublicLiteralType = (name, literals) => exports.f.createTypeAliasDeclaration(undefined, exports.exportModifier, name, undefined, exports.f.createUnionTypeNode(literals.map((option) => exports.f.createLiteralTypeNode(exports.f.createStringLiteral(option)))));
exports.makePublicLiteralType = makePublicLiteralType;
const makePublicType = (name, value) => exports.f.createTypeAliasDeclaration(undefined, exports.exportModifier, name, undefined, value);
exports.makePublicType = makePublicType;
const makePublicReadonlyProp = (name, type, exp) => exports.f.createPropertyDeclaration(undefined, exports.publicReadonlyModifier, name, undefined, type, exp);
exports.makePublicReadonlyProp = makePublicReadonlyProp;
const makePublicClass = (name, constructor, props = []) => exports.f.createClassDeclaration(undefined, exports.exportModifier, name, undefined, undefined, [constructor, ...props]);
exports.makePublicClass = makePublicClass;
const makeIndexedPromise = (type, index) => exports.f.createTypeReferenceNode("Promise", [
    exports.f.createIndexedAccessTypeNode(exports.f.createTypeReferenceNode(type), index),
]);
exports.makeIndexedPromise = makeIndexedPromise;
const makeAnyPromise = () => exports.f.createTypeReferenceNode("Promise", [
    exports.f.createKeywordTypeNode(typescript_1.default.SyntaxKind.AnyKeyword),
]);
exports.makeAnyPromise = makeAnyPromise;
const makePublicExtendedInterface = (name, extender, props) => exports.f.createInterfaceDeclaration(undefined, exports.exportModifier, name, undefined, extender, props);
exports.makePublicExtendedInterface = makePublicExtendedInterface;
const makeTypeParams = (params) => Object.keys(params).reduce((acc, name) => acc.concat(exports.f.createTypeParameterDeclaration([], name, exports.f.createTypeReferenceNode(params[name]))), []);
exports.makeTypeParams = makeTypeParams;
const makeImplementationCallFn = (params, args) => exports.f.createArrowFunction(undefined, undefined, params.map((key) => (0, exports.makeParam)(key)), undefined, undefined, exports.f.createCallExpression(exports.f.createPropertyAccessExpression(exports.f.createThis(), "implementation"), undefined, args));
exports.makeImplementationCallFn = makeImplementationCallFn;
const makeObjectKeysReducer = (obj, exp, initial) => exports.f.createCallExpression(exports.f.createPropertyAccessExpression(exports.f.createCallExpression(exports.f.createPropertyAccessExpression(exports.f.createIdentifier("Object"), "keys"), undefined, [exports.f.createIdentifier(obj)]), "reduce"), undefined, [
    exports.f.createArrowFunction(undefined, undefined, (0, exports.makeParams)({ acc: undefined, key: undefined }), undefined, undefined, exp),
    initial,
]);
exports.makeObjectKeysReducer = makeObjectKeysReducer;
const cleanId = (path, method, suffix) => {
    return [method]
        .concat(path.split("/"))
        .concat(suffix)
        .map((entry) => entry.replace(/[^A-Z0-9]/i, ""))
        .map((entry) => entry.slice(0, 1).toUpperCase() + entry.slice(1).toLowerCase())
        .join("");
};
exports.cleanId = cleanId;
//# sourceMappingURL=client-helpers.js.map