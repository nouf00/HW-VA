"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.errToObj = exports.hasUpload = exports.hasTopLevelTransformingEffect = exports.getRoutePathParams = exports.combinations = exports.getExamples = exports.getStatusCodeFromError = exports.getMessageFromError = exports.makeErrorFromAnything = exports.isValidDate = exports.isLoggerConfig = exports.getInput = exports.getActualMethod = exports.defaultInputSources = exports.routePathParamsRegex = void 0;
const http_errors_1 = require("http-errors");
const zod_1 = require("zod");
const config_type_1 = require("./config-type");
const metadata_1 = require("./metadata");
const mime_1 = require("./mime");
const upload_schema_1 = require("./upload-schema");
/** @see https://expressjs.com/en/guide/routing.html */
exports.routePathParamsRegex = /:([A-Za-z0-9_]+)/g;
function areFilesAvailable(request) {
    const contentType = request.header("content-type") || "";
    const isMultipart = contentType.slice(0, mime_1.mimeMultipart.length).toLowerCase() === mime_1.mimeMultipart;
    return "files" in request && isMultipart;
}
exports.defaultInputSources = {
    get: ["query", "params"],
    post: ["body", "params", "files"],
    put: ["body", "params"],
    patch: ["body", "params"],
    delete: ["body", "query", "params"],
};
const fallbackInputSource = exports.defaultInputSources.delete;
const getActualMethod = (request) => request.method.toLowerCase();
exports.getActualMethod = getActualMethod;
function getInput(request, inputAssignment) {
    const method = (0, exports.getActualMethod)(request);
    if (method === "options") {
        return {};
    }
    let props = fallbackInputSource;
    if (method in exports.defaultInputSources) {
        props = exports.defaultInputSources[method];
    }
    if (inputAssignment && method in inputAssignment) {
        props = inputAssignment[method] || props;
    }
    return props
        .filter((prop) => (prop === "files" ? areFilesAvailable(request) : true))
        .reduce((carry, prop) => ({
        ...carry,
        ...request[prop],
    }), {});
}
exports.getInput = getInput;
function isLoggerConfig(logger) {
    return (typeof logger === "object" &&
        "level" in logger &&
        "color" in logger &&
        Object.keys(config_type_1.loggerLevels).includes(logger.level) &&
        typeof logger.color === "boolean");
}
exports.isLoggerConfig = isLoggerConfig;
function isValidDate(date) {
    return !isNaN(date.getTime());
}
exports.isValidDate = isValidDate;
function makeErrorFromAnything(subject) {
    return subject instanceof Error
        ? subject
        : new Error(typeof subject === "symbol" ? subject.toString() : `${subject}`);
}
exports.makeErrorFromAnything = makeErrorFromAnything;
function getMessageFromError(error) {
    if (error instanceof zod_1.z.ZodError) {
        return error.issues
            .map(({ path, message }) => (path.length ? [path.join("/")] : []).concat(message).join(": "))
            .join("; ");
    }
    return error.message;
}
exports.getMessageFromError = getMessageFromError;
function getStatusCodeFromError(error) {
    if (error instanceof http_errors_1.HttpError) {
        return error.statusCode;
    }
    if (error instanceof zod_1.z.ZodError) {
        return 400;
    }
    return 500;
}
exports.getStatusCodeFromError = getStatusCodeFromError;
const getExamples = (schema, parseToOutput) => {
    const examples = (0, metadata_1.getMeta)(schema, "examples");
    if (examples === undefined) {
        return [];
    }
    return examples.reduce((carry, example) => {
        const parsedExample = schema.safeParse(example);
        return carry.concat(parsedExample.success
            ? parseToOutput
                ? parsedExample.data
                : example
            : []);
    }, []);
};
exports.getExamples = getExamples;
const combinations = (a, b) => {
    if (a.length === 0) {
        return { type: "single", value: b };
    }
    if (b.length === 0) {
        return { type: "single", value: a };
    }
    const result = [];
    for (const itemA of a) {
        for (const itemB of b) {
            result.push([itemA, itemB]);
        }
    }
    return { type: "tuple", value: result };
};
exports.combinations = combinations;
function getRoutePathParams(path) {
    const match = path.match(exports.routePathParamsRegex);
    if (!match) {
        return [];
    }
    return match.map((param) => param.slice(1));
}
exports.getRoutePathParams = getRoutePathParams;
const reduceBool = (arr) => arr.reduce((carry, bool) => carry || bool, false);
function hasTopLevelTransformingEffect(schema) {
    if (schema instanceof zod_1.z.ZodEffects) {
        if (schema._def.effect.type !== "refinement") {
            return true;
        }
    }
    if (schema instanceof zod_1.z.ZodUnion) {
        return reduceBool(schema.options.map(hasTopLevelTransformingEffect));
    }
    if (schema instanceof zod_1.z.ZodIntersection) {
        return reduceBool([schema._def.left, schema._def.right].map(hasTopLevelTransformingEffect));
    }
    return false; // ZodObject left
}
exports.hasTopLevelTransformingEffect = hasTopLevelTransformingEffect;
function hasUpload(schema) {
    if (schema instanceof upload_schema_1.ZodUpload) {
        return true;
    }
    if (schema instanceof zod_1.z.ZodObject) {
        return reduceBool(Object.values(schema.shape).map(hasUpload));
    }
    if (schema instanceof zod_1.z.ZodUnion) {
        return reduceBool(schema.options.map(hasUpload));
    }
    if (schema instanceof zod_1.z.ZodIntersection) {
        return reduceBool([schema._def.left, schema._def.right].map(hasUpload));
    }
    if (schema instanceof zod_1.z.ZodOptional || schema instanceof zod_1.z.ZodNullable) {
        return hasUpload(schema.unwrap());
    }
    if (schema instanceof zod_1.z.ZodEffects || schema instanceof zod_1.z.ZodTransformer) {
        return hasUpload(schema._def.schema);
    }
    if (schema instanceof zod_1.z.ZodRecord) {
        return hasUpload(schema._def.valueType);
    }
    if (schema instanceof zod_1.z.ZodArray) {
        return hasUpload(schema._def.type);
    }
    if (schema instanceof zod_1.z.ZodDefault) {
        return hasUpload(schema._def.innerType);
    }
    return false;
}
exports.hasUpload = hasUpload;
// the copy of the private Zod errorUtil.errToObj
const errToObj = (message) => typeof message === "string" ? { message } : message || {};
exports.errToObj = errToObj;
//# sourceMappingURL=common-helpers.js.map