/// <reference types="qs" />
import { Request, Response } from "express";
import { z } from "zod";
import { ApiResponse } from "./api-response";
import { FlatObject } from "./common-helpers";
import { CommonConfig } from "./config-type";
import { Endpoint, Handler } from "./endpoint";
import { IOSchema, ProbableIntersection } from "./io-schema";
import { Method, MethodsDefinition } from "./method";
import { AnyMiddlewareDef, ExpressMiddleware, ExpressMiddlewareFeatures, MiddlewareDefinition } from "./middleware";
import { ResultHandlerDefinition } from "./result-handler";
type BuildProps<IN extends IOSchema, OUT extends IOSchema, MIN extends IOSchema<"strip"> | null, OPT extends FlatObject, M extends Method, SCO extends string, TAG extends string> = {
    input: IN;
    output: OUT;
    handler: Handler<z.output<ProbableIntersection<MIN, IN>>, z.input<OUT>, OPT>;
    description?: string;
    shortDescription?: string;
} & ({
    scopes?: SCO[];
} | {
    scope?: SCO;
}) & ({
    tags?: TAG[];
} | {
    tag?: TAG;
}) & MethodsDefinition<M>;
export declare class EndpointsFactory<POS extends ApiResponse, NEG extends ApiResponse, IN extends IOSchema<"strip"> | null = null, OUT extends FlatObject = {}, SCO extends string = string, TAG extends string = string> {
    #private;
    protected resultHandler: ResultHandlerDefinition<POS, NEG>;
    protected middlewares: AnyMiddlewareDef[];
    constructor(resultHandler: ResultHandlerDefinition<POS, NEG>);
    /** @desc Consider using the "config" prop with the "tags" option to enforce constraints on tagging the endpoints */
    constructor(params: {
        resultHandler: ResultHandlerDefinition<POS, NEG>;
        config?: CommonConfig<TAG>;
    });
    addMiddleware<AIN extends IOSchema<"strip">, AOUT extends FlatObject, ASCO extends string>(subject: MiddlewareDefinition<AIN, OUT, AOUT, ASCO>): EndpointsFactory<POS, NEG, ProbableIntersection<IN, AIN>, OUT & AOUT, SCO & ASCO, TAG>;
    use: <R extends Request<import("express-serve-static-core").ParamsDictionary, any, any, import("qs").ParsedQs, Record<string, any>>, S extends Response<any, Record<string, any>>, AOUT extends FlatObject = {}>(middleware: ExpressMiddleware<R, S>, features?: ExpressMiddlewareFeatures<R, S, AOUT> | undefined) => EndpointsFactory<POS, NEG, IN, OUT & AOUT, SCO, TAG>;
    addExpressMiddleware<R extends Request, S extends Response, AOUT extends FlatObject = {}>(middleware: ExpressMiddleware<R, S>, features?: ExpressMiddlewareFeatures<R, S, AOUT>): EndpointsFactory<POS, NEG, IN, OUT & AOUT, SCO, TAG>;
    addOptions<AOUT extends FlatObject>(options: AOUT): EndpointsFactory<POS, NEG, IN, OUT & AOUT, SCO, TAG>;
    build<BIN extends IOSchema, BOUT extends IOSchema, M extends Method>({ input, handler, output: outputSchema, ...rest }: BuildProps<BIN, BOUT, IN, OUT, M, SCO, TAG>): Endpoint<ProbableIntersection<IN, BIN>, BOUT, OUT, M, POS, NEG, SCO, TAG>;
}
export declare const defaultEndpointsFactory: EndpointsFactory<ApiResponse<z.ZodObject<{
    status: z.ZodLiteral<"success">;
    data: IOSchema<any>;
}, "strip", z.ZodTypeAny, {
    data?: unknown;
    status: "success";
}, {
    data?: unknown;
    status: "success";
}> & {
    keyof: () => z.ZodEnum<never>;
} & {
    _def: z.ZodObjectDef<{
        status: z.ZodLiteral<"success">;
        data: IOSchema<any>;
    }, "strip", z.ZodTypeAny> & import("./metadata").MetaDef<z.ZodObject<{
        status: z.ZodLiteral<"success">;
        data: IOSchema<any>;
    }, "strip", z.ZodTypeAny, {
        data?: unknown;
        status: "success";
    }, {
        data?: unknown;
        status: "success";
    }>>;
    example: (example: {
        data?: unknown;
        status: "success";
    }) => z.ZodObject<{
        status: z.ZodLiteral<"success">;
        data: IOSchema<any>;
    }, "strip", z.ZodTypeAny, {
        data?: unknown;
        status: "success";
    }, {
        data?: unknown;
        status: "success";
    }> & {
        keyof: () => z.ZodEnum<never>;
    } & any;
}>, ApiResponse<z.ZodObject<{
    status: z.ZodLiteral<"error">;
    error: z.ZodObject<{
        message: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        message: string;
    }, {
        message: string;
    }>;
}, "strip", z.ZodTypeAny, {
    status: "error";
    error: {
        message: string;
    };
}, {
    status: "error";
    error: {
        message: string;
    };
}> & {
    keyof: () => z.ZodEnum<never>;
} & {
    _def: z.ZodObjectDef<{
        status: z.ZodLiteral<"error">;
        error: z.ZodObject<{
            message: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            message: string;
        }, {
            message: string;
        }>;
    }, "strip", z.ZodTypeAny> & import("./metadata").MetaDef<z.ZodObject<{
        status: z.ZodLiteral<"error">;
        error: z.ZodObject<{
            message: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            message: string;
        }, {
            message: string;
        }>;
    }, "strip", z.ZodTypeAny, {
        status: "error";
        error: {
            message: string;
        };
    }, {
        status: "error";
        error: {
            message: string;
        };
    }>>;
    example: (example: {
        status: "error";
        error: {
            message: string;
        };
    }) => z.ZodObject<{
        status: z.ZodLiteral<"error">;
        error: z.ZodObject<{
            message: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            message: string;
        }, {
            message: string;
        }>;
    }, "strip", z.ZodTypeAny, {
        status: "error";
        error: {
            message: string;
        };
    }, {
        status: "error";
        error: {
            message: string;
        };
    }> & {
        keyof: () => z.ZodEnum<never>;
    } & any;
}>, null, {}, string, string>;
export {};
