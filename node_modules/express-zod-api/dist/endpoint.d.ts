import { Request, Response } from "express";
import { Logger } from "winston";
import { z } from "zod";
import { ApiResponse } from "./api-response";
import { CommonConfig } from "./config-type";
import { FlatObject } from "./common-helpers";
import { IOSchema } from "./io-schema";
import { LogicalContainer } from "./logical-container";
import { Method, MethodsDefinition } from "./method";
import { AnyMiddlewareDef } from "./middleware";
import { ResultHandlerDefinition } from "./result-handler";
import { Security } from "./security";
export type Handler<IN, OUT, OPT> = (params: {
    input: IN;
    options: OPT;
    logger: Logger;
}) => Promise<OUT>;
export declare abstract class AbstractEndpoint {
    abstract execute(params: {
        request: Request;
        response: Response;
        logger: Logger;
        config: CommonConfig;
    }): Promise<void>;
    abstract getDescription(variant: "short" | "long"): string | undefined;
    abstract getMethods(): Method[];
    abstract getInputSchema(): IOSchema;
    abstract getOutputSchema(): IOSchema;
    abstract getPositiveResponseSchema(): z.ZodTypeAny;
    abstract getNegativeResponseSchema(): z.ZodTypeAny;
    abstract getInputMimeTypes(): string[];
    abstract getPositiveMimeTypes(): string[];
    abstract getNegativeMimeTypes(): string[];
    abstract getSecurity(): LogicalContainer<Security>;
    abstract getScopes(): string[];
    abstract getTags(): string[];
}
type EndpointProps<IN extends IOSchema, OUT extends IOSchema, OPT extends FlatObject, M extends Method, POS extends ApiResponse, NEG extends ApiResponse, SCO extends string, TAG extends string> = {
    middlewares: AnyMiddlewareDef[];
    inputSchema: IN;
    mimeTypes: string[];
    outputSchema: OUT;
    handler: Handler<z.output<IN>, z.input<OUT>, OPT>;
    resultHandler: ResultHandlerDefinition<POS, NEG>;
    description?: string;
    shortDescription?: string;
} & ({
    scopes?: SCO[];
} | {
    scope?: SCO;
}) & ({
    tags?: TAG[];
} | {
    tag?: TAG;
}) & MethodsDefinition<M>;
export declare class Endpoint<IN extends IOSchema, OUT extends IOSchema, OPT extends FlatObject, M extends Method, POS extends ApiResponse, NEG extends ApiResponse, SCO extends string, TAG extends string> extends AbstractEndpoint {
    #private;
    protected readonly descriptions: Record<"short" | "long", string | undefined>;
    protected readonly methods: M[];
    protected readonly middlewares: AnyMiddlewareDef[];
    protected readonly inputSchema: IN;
    protected readonly mimeTypes: string[];
    protected readonly outputSchema: OUT;
    protected readonly handler: Handler<z.output<IN>, z.input<OUT>, OPT>;
    protected readonly resultHandler: ResultHandlerDefinition<POS, NEG>;
    protected readonly scopes: SCO[];
    protected readonly tags: TAG[];
    constructor({ middlewares, inputSchema, outputSchema, handler, resultHandler, description, shortDescription, mimeTypes, ...rest }: EndpointProps<IN, OUT, OPT, M, POS, NEG, SCO, TAG>);
    getDescription(variant: "short" | "long"): string | undefined;
    getMethods(): M[];
    getInputSchema(): IN;
    getOutputSchema(): OUT;
    getPositiveResponseSchema(): POS["schema"];
    getNegativeResponseSchema(): NEG["schema"];
    getInputMimeTypes(): string[];
    getPositiveMimeTypes(): string[];
    getNegativeMimeTypes(): string[];
    getSecurity(): LogicalContainer<Security<string, string>>;
    getScopes(): SCO[];
    getTags(): TAG[];
    execute({ request, response, logger, config, }: {
        request: Request;
        response: Response;
        logger: Logger;
        config: CommonConfig;
    }): Promise<void>;
}
export {};
