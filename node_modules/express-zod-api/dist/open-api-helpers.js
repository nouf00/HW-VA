"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ensureShortDescription = exports.depictTags = exports.depictRequest = exports.depictSecurityRefs = exports.depictSecurity = exports.depictResponse = exports.excludeExampleFromDepiction = exports.excludeParamsFromDepiction = exports.depictSchema = exports.depictRequestParams = exports.extractObjectSchema = exports.depictIOParamExamples = exports.depictIOExamples = exports.depictZodBranded = exports.depictEffect = exports.depictObjectProperties = exports.depictNumber = exports.depictString = exports.depictTuple = exports.depictArray = exports.depictRecord = exports.depictBigInt = exports.depictBoolean = exports.depictZodDate = exports.depictDateOut = exports.depictDateIn = exports.depictNull = exports.depictObject = exports.depictLiteral = exports.depictEnum = exports.depictOptionalOrNullable = exports.depictIntersection = exports.depictDiscriminatedUnion = exports.depictUnion = exports.depictFile = exports.depictUpload = exports.depictAny = exports.depictDefault = exports.reformatParamsInPath = void 0;
const ramda_1 = require("ramda");
const zod_1 = require("zod");
const common_helpers_1 = require("./common-helpers");
const date_in_schema_1 = require("./date-in-schema");
const errors_1 = require("./errors");
const logical_container_1 = require("./logical-container");
const metadata_1 = require("./metadata");
const shortDescriptionLimit = 50;
const isoDateDocumentationUrl = "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString";
/* eslint-disable @typescript-eslint/no-use-before-define */
const reformatParamsInPath = (path) => path.replace(common_helpers_1.routePathParamsRegex, (param) => `{${param.slice(1)}}`);
exports.reformatParamsInPath = reformatParamsInPath;
const depictDefault = ({ schema: { _def: { innerType, defaultValue }, }, initial, isResponse, }) => ({
    ...initial,
    ...(0, exports.depictSchema)({ schema: innerType, initial, isResponse }),
    default: defaultValue(),
});
exports.depictDefault = depictDefault;
const depictAny = ({ initial }) => ({
    ...initial,
    format: "any",
});
exports.depictAny = depictAny;
const depictUpload = ({ initial, isResponse, }) => {
    if (isResponse) {
        throw new errors_1.OpenAPIError("Please use z.upload() only for input.");
    }
    return {
        ...initial,
        type: "string",
        format: "binary",
    };
};
exports.depictUpload = depictUpload;
const depictFile = ({ schema: { isBinary, isBase64 }, initial, isResponse, }) => {
    if (!isResponse) {
        throw new errors_1.OpenAPIError("Please use z.file() only within ResultHandler.");
    }
    return {
        ...initial,
        type: "string",
        format: isBinary ? "binary" : isBase64 ? "byte" : "file",
    };
};
exports.depictFile = depictFile;
const depictUnion = ({ schema: { options }, initial, isResponse }) => ({
    ...initial,
    oneOf: options.map((option) => (0, exports.depictSchema)({ schema: option, isResponse })),
});
exports.depictUnion = depictUnion;
const depictDiscriminatedUnion = ({ schema: { options, discriminator }, initial, isResponse }) => {
    return {
        ...initial,
        discriminator: {
            propertyName: discriminator,
        },
        oneOf: Array.from(options.values()).map((option) => (0, exports.depictSchema)({ schema: option, isResponse })),
    };
};
exports.depictDiscriminatedUnion = depictDiscriminatedUnion;
const depictIntersection = ({ schema: { _def: { left, right }, }, initial, isResponse, }) => ({
    ...initial,
    allOf: [
        (0, exports.depictSchema)({ schema: left, isResponse }),
        (0, exports.depictSchema)({ schema: right, isResponse }),
    ],
});
exports.depictIntersection = depictIntersection;
const depictOptionalOrNullable = ({ schema, initial, isResponse }) => ({
    ...initial,
    ...(0, exports.depictSchema)({ schema: schema.unwrap(), isResponse }),
});
exports.depictOptionalOrNullable = depictOptionalOrNullable;
const depictEnum = ({ schema: { _def: { values }, }, initial, }) => ({
    ...initial,
    type: typeof Object.values(values)[0],
    enum: Object.values(values),
});
exports.depictEnum = depictEnum;
const depictLiteral = ({ schema: { _def: { value }, }, initial, }) => ({
    ...initial,
    type: typeof value,
    enum: [value],
});
exports.depictLiteral = depictLiteral;
const depictObject = ({ schema, initial, isResponse, }) => ({
    ...initial,
    type: "object",
    properties: (0, exports.depictObjectProperties)({ schema, isResponse }),
    required: Object.keys(schema.shape).filter((key) => !schema.shape[key].isOptional()),
});
exports.depictObject = depictObject;
/** @see https://swagger.io/docs/specification/data-models/data-types/ */
const depictNull = ({ initial }) => ({
    ...initial,
    type: "string",
    nullable: true,
    format: "null",
});
exports.depictNull = depictNull;
const depictDateIn = ({ initial, isResponse, }) => {
    if (isResponse) {
        throw new errors_1.OpenAPIError("Please use z.dateOut() for output.");
    }
    return {
        description: "YYYY-MM-DDTHH:mm:ss.sssZ",
        ...initial,
        type: "string",
        format: "date-time",
        pattern: date_in_schema_1.isoDateRegex.source,
        externalDocs: {
            url: isoDateDocumentationUrl,
        },
    };
};
exports.depictDateIn = depictDateIn;
const depictDateOut = ({ initial, isResponse, }) => {
    if (!isResponse) {
        throw new errors_1.OpenAPIError("Please use z.dateIn() for input.");
    }
    return {
        description: "YYYY-MM-DDTHH:mm:ss.sssZ",
        ...initial,
        type: "string",
        format: "date-time",
        externalDocs: {
            url: isoDateDocumentationUrl,
        },
    };
};
exports.depictDateOut = depictDateOut;
/** @throws OpenAPIError */
const depictZodDate = ({ isResponse }) => {
    throw new errors_1.OpenAPIError(`Using z.date() within ${isResponse ? "output" : "input"} schema is forbidden. Please use z.date${isResponse ? "Out" : "In"}() instead. Check out the documentation for details.`);
};
exports.depictZodDate = depictZodDate;
const depictBoolean = ({ initial }) => ({
    ...initial,
    type: "boolean",
});
exports.depictBoolean = depictBoolean;
const depictBigInt = ({ initial }) => ({
    ...initial,
    type: "integer",
    format: "bigint",
});
exports.depictBigInt = depictBigInt;
const depictRecord = ({ schema: { _def: def }, initial, isResponse, }) => {
    if (def.keyType instanceof zod_1.z.ZodEnum ||
        def.keyType instanceof zod_1.z.ZodNativeEnum) {
        const keys = Object.values(def.keyType._def.values);
        const shape = keys.reduce((carry, key) => ({
            ...carry,
            [key]: def.valueType,
        }), {});
        return {
            ...initial,
            type: "object",
            properties: (0, exports.depictObjectProperties)({
                schema: zod_1.z.object(shape),
                isResponse,
            }),
            required: keys,
        };
    }
    if (def.keyType instanceof zod_1.z.ZodLiteral) {
        return {
            ...initial,
            type: "object",
            properties: (0, exports.depictObjectProperties)({
                schema: zod_1.z.object({
                    [def.keyType._def.value]: def.valueType,
                }),
                isResponse,
            }),
            required: [def.keyType._def.value],
        };
    }
    if (def.keyType instanceof zod_1.z.ZodUnion) {
        const areOptionsLiteral = def.keyType.options.reduce((carry, option) => carry && option instanceof zod_1.z.ZodLiteral, true);
        if (areOptionsLiteral) {
            const shape = def.keyType.options.reduce((carry, option) => ({
                ...carry,
                [option.value]: def.valueType,
            }), {});
            return {
                ...initial,
                type: "object",
                properties: (0, exports.depictObjectProperties)({
                    schema: zod_1.z.object(shape),
                    isResponse,
                }),
                required: def.keyType.options.map((option) => option.value),
            };
        }
    }
    return {
        ...initial,
        type: "object",
        additionalProperties: (0, exports.depictSchema)({ schema: def.valueType, isResponse }),
    };
};
exports.depictRecord = depictRecord;
const depictArray = ({ schema: { _def: def }, initial, isResponse, }) => ({
    ...initial,
    type: "array",
    items: (0, exports.depictSchema)({ schema: def.type, isResponse }),
    ...(def.minLength ? { minItems: def.minLength.value } : {}),
    ...(def.maxLength ? { maxItems: def.maxLength.value } : {}),
});
exports.depictArray = depictArray;
/** @todo improve it when OpenAPI 3.1.0 will be released */
const depictTuple = ({ schema: { items }, initial, isResponse, }) => {
    const types = items.map((item) => (0, exports.depictSchema)({ schema: item, isResponse }));
    return {
        ...initial,
        type: "array",
        minItems: types.length,
        maxItems: types.length,
        items: {
            oneOf: types,
            format: "tuple",
            ...(types.length === 0
                ? {}
                : {
                    description: types
                        .map((item, index) => `${index}: ${item.type}`)
                        .join(", "),
                }),
        },
    };
};
exports.depictTuple = depictTuple;
const depictString = ({ schema: { _def: { checks }, }, initial, }) => {
    const isEmail = checks.find(({ kind }) => kind === "email") !== undefined;
    const isUrl = checks.find(({ kind }) => kind === "url") !== undefined;
    const isUUID = checks.find(({ kind }) => kind === "uuid") !== undefined;
    const isCUID = checks.find(({ kind }) => kind === "cuid") !== undefined;
    const minLengthCheck = checks.find(({ kind }) => kind === "min");
    const maxLengthCheck = checks.find(({ kind }) => kind === "max");
    const regexCheck = checks.find(({ kind }) => kind === "regex");
    return {
        ...initial,
        type: "string",
        ...(isEmail ? { format: "email" } : {}),
        ...(isUrl ? { format: "url" } : {}),
        ...(isUUID ? { format: "uuid" } : {}),
        ...(isCUID ? { format: "cuid" } : {}),
        ...(minLengthCheck ? { minLength: minLengthCheck.value } : {}),
        ...(maxLengthCheck ? { maxLength: maxLengthCheck.value } : {}),
        ...(regexCheck
            ? { pattern: `/${regexCheck.regex.source}/${regexCheck.regex.flags}` }
            : {}),
    };
};
exports.depictString = depictString;
/** @todo support exclusive min/max as numbers in case of OpenAPI v3.1.x */
const depictNumber = ({ schema, initial, }) => {
    const minCheck = schema._def.checks.find(({ kind }) => kind === "min");
    const isMinInclusive = minCheck ? minCheck.inclusive : true;
    const maxCheck = schema._def.checks.find(({ kind }) => kind === "max");
    const isMaxInclusive = maxCheck ? maxCheck.inclusive : true;
    return {
        ...initial,
        type: schema.isInt ? "integer" : "number",
        format: schema.isInt ? "int64" : "double",
        minimum: schema.minValue === null
            ? schema.isInt
                ? Number.MIN_SAFE_INTEGER
                : Number.MIN_VALUE
            : schema.minValue,
        exclusiveMinimum: !isMinInclusive,
        maximum: schema.maxValue === null
            ? schema.isInt
                ? Number.MAX_SAFE_INTEGER
                : Number.MAX_VALUE
            : schema.maxValue,
        exclusiveMaximum: !isMaxInclusive,
    };
};
exports.depictNumber = depictNumber;
const depictObjectProperties = ({ schema: { shape }, isResponse, }) => {
    return Object.keys(shape).reduce((carry, key) => ({
        ...carry,
        [key]: (0, exports.depictSchema)({ schema: shape[key], isResponse }),
    }), {});
};
exports.depictObjectProperties = depictObjectProperties;
const depictEffect = ({ schema, initial, isResponse, }) => {
    const input = (0, exports.depictSchema)({ schema: schema._def.schema, isResponse });
    const effect = schema._def.effect;
    if (isResponse && effect && effect.type === "transform") {
        let output = "undefined";
        try {
            output = typeof effect.transform(["integer", "number"].includes(`${input.type}`)
                ? 0
                : "string" === input.type
                    ? ""
                    : "boolean" === input.type
                        ? false
                        : "object" === input.type
                            ? {}
                            : "null" === input.type
                                ? null
                                : "array" === input.type
                                    ? []
                                    : undefined, { addIssue: () => { }, path: [] });
        }
        catch (e) {
            /**/
        }
        return {
            ...initial,
            ...input,
            ...(["number", "string", "boolean"].includes(output)
                ? {
                    type: output,
                }
                : {}),
        };
    }
    if (!isResponse && effect && effect.type === "preprocess") {
        const { type: inputType, ...rest } = input;
        return {
            ...initial,
            ...rest,
            format: `${rest.format || inputType} (preprocessed)`,
        };
    }
    return { ...initial, ...input };
};
exports.depictEffect = depictEffect;
const depictZodBranded = ({ schema, initial, isResponse }) => (0, exports.depictSchema)({ schema: schema.unwrap(), isResponse, initial });
exports.depictZodBranded = depictZodBranded;
const depictIOExamples = (schema, isResponse, omitProps = []) => {
    const examples = (0, common_helpers_1.getExamples)(schema, isResponse);
    if (examples.length === 0) {
        return {};
    }
    return {
        examples: examples.reduce((carry, example, index) => ({
            ...carry,
            [`example${index + 1}`]: {
                value: (0, ramda_1.omit)(omitProps, example),
            },
        }), {}),
    };
};
exports.depictIOExamples = depictIOExamples;
const depictIOParamExamples = (schema, isResponse, param) => {
    const examples = (0, common_helpers_1.getExamples)(schema, isResponse);
    if (examples.length === 0) {
        return {};
    }
    return {
        examples: examples.reduce((carry, example, index) => param in example
            ? {
                ...carry,
                [`example${index + 1}`]: {
                    value: example[param],
                },
            }
            : carry, {}),
    };
};
exports.depictIOParamExamples = depictIOParamExamples;
function extractObjectSchema(subject) {
    if (subject instanceof zod_1.z.ZodObject) {
        return subject;
    }
    let objectSchema;
    if (subject instanceof zod_1.z.ZodUnion ||
        subject instanceof zod_1.z.ZodDiscriminatedUnion) {
        objectSchema = Array.from(subject.options.values())
            .map((option) => extractObjectSchema(option))
            .reduce((acc, option) => acc.merge(option.partial()), zod_1.z.object({}));
    }
    else if (subject instanceof zod_1.z.ZodEffects) {
        if ((0, common_helpers_1.hasTopLevelTransformingEffect)(subject)) {
            throw new errors_1.OpenAPIError("Using transformations on the top level of input schema is not allowed.");
        }
        objectSchema = extractObjectSchema(subject._def.schema); // object refinement
    }
    else {
        // intersection
        objectSchema = extractObjectSchema(subject._def.left).merge(extractObjectSchema(subject._def.right));
    }
    return (0, metadata_1.copyMeta)(subject, objectSchema);
}
exports.extractObjectSchema = extractObjectSchema;
const depictRequestParams = ({ path, method, endpoint, inputSources, }) => {
    const schema = endpoint.getInputSchema();
    const shape = extractObjectSchema(schema).shape;
    const pathParams = (0, common_helpers_1.getRoutePathParams)(path);
    const isQueryEnabled = inputSources.includes("query");
    const isParamsEnabled = inputSources.includes("params");
    const isPathParam = (name) => isParamsEnabled && pathParams.includes(name);
    return Object.keys(shape)
        .filter((name) => isQueryEnabled || isPathParam(name))
        .map((name) => ({
        name,
        in: isPathParam(name) ? "path" : "query",
        required: !shape[name].isOptional(),
        schema: {
            description: `${method.toUpperCase()} ${path} parameter`,
            ...(0, exports.depictSchema)({ schema: shape[name], isResponse: false }),
        },
        ...(0, exports.depictIOParamExamples)(schema, false, name),
    }));
};
exports.depictRequestParams = depictRequestParams;
const depictHelpers = {
    ZodString: exports.depictString,
    ZodNumber: exports.depictNumber,
    ZodBigInt: exports.depictBigInt,
    ZodBoolean: exports.depictBoolean,
    ZodDateIn: exports.depictDateIn,
    ZodDateOut: exports.depictDateOut,
    ZodNull: exports.depictNull,
    ZodArray: exports.depictArray,
    ZodTuple: exports.depictTuple,
    ZodRecord: exports.depictRecord,
    ZodObject: exports.depictObject,
    ZodLiteral: exports.depictLiteral,
    ZodIntersection: exports.depictIntersection,
    ZodUnion: exports.depictUnion,
    ZodFile: exports.depictFile,
    ZodUpload: exports.depictUpload,
    ZodAny: exports.depictAny,
    ZodDefault: exports.depictDefault,
    ZodEnum: exports.depictEnum,
    ZodNativeEnum: exports.depictEnum,
    ZodEffects: exports.depictEffect,
    ZodOptional: exports.depictOptionalOrNullable,
    ZodNullable: exports.depictOptionalOrNullable,
    ZodDiscriminatedUnion: exports.depictDiscriminatedUnion,
    ZodBranded: exports.depictZodBranded,
    ZodDate: exports.depictZodDate,
};
const depictSchema = ({ schema, isResponse, }) => {
    const initial = {};
    if (schema.isNullable()) {
        initial.nullable = true;
    }
    if (schema.description) {
        initial.description = `${schema.description}`;
    }
    const examples = (0, common_helpers_1.getExamples)(schema, isResponse);
    if (examples.length > 0) {
        initial.example = examples[0];
    }
    const nextHelper = "typeName" in schema._def
        ? depictHelpers[schema._def.typeName]
        : null;
    if (!nextHelper) {
        throw new errors_1.OpenAPIError(`Zod type ${schema.constructor.name} is unsupported`);
    }
    return nextHelper({ schema, initial, isResponse });
};
exports.depictSchema = depictSchema;
const excludeParamsFromDepiction = (depicted, pathParams) => {
    const properties = depicted.properties
        ? (0, ramda_1.omit)(pathParams, depicted.properties)
        : undefined;
    const example = depicted.example
        ? (0, ramda_1.omit)(pathParams, depicted.example)
        : undefined;
    const required = depicted.required
        ? depicted.required.filter((name) => !pathParams.includes(name))
        : undefined;
    const allOf = depicted.allOf
        ? depicted.allOf.map((entry) => (0, exports.excludeParamsFromDepiction)(entry, pathParams))
        : undefined;
    const oneOf = depicted.oneOf
        ? depicted.oneOf.map((entry) => (0, exports.excludeParamsFromDepiction)(entry, pathParams))
        : undefined;
    return (0, ramda_1.omit)(Object.entries({ properties, required, example, allOf, oneOf })
        .filter(([{}, value]) => value === undefined)
        .map(([key]) => key), {
        ...depicted,
        properties,
        required,
        example,
        allOf,
        oneOf,
    });
};
exports.excludeParamsFromDepiction = excludeParamsFromDepiction;
const excludeExampleFromDepiction = (depicted) => (0, ramda_1.omit)(["example"], depicted);
exports.excludeExampleFromDepiction = excludeExampleFromDepiction;
const depictResponse = ({ method, path, description, endpoint, isPositive, }) => {
    const schema = isPositive
        ? endpoint.getPositiveResponseSchema()
        : endpoint.getNegativeResponseSchema();
    const mimeTypes = isPositive
        ? endpoint.getPositiveMimeTypes()
        : endpoint.getNegativeMimeTypes();
    const depictedSchema = (0, exports.excludeExampleFromDepiction)((0, exports.depictSchema)({
        schema,
        isResponse: true,
    }));
    const examples = (0, exports.depictIOExamples)(schema, true);
    return {
        description: `${method.toUpperCase()} ${path} ${description}`,
        content: mimeTypes.reduce((carry, mimeType) => ({
            ...carry,
            [mimeType]: {
                schema: depictedSchema,
                ...examples,
            },
        }), {}),
    };
};
exports.depictResponse = depictResponse;
const depictBasicSecurity = ({}) => ({
    type: "http",
    scheme: "basic",
});
const depictBearerSecurity = ({ format: bearerFormat, }) => ({
    type: "http",
    scheme: "bearer",
    ...(bearerFormat ? { bearerFormat } : {}),
});
// @todo add description on actual input placement
const depictInputSecurity = ({ name }) => ({
    type: "apiKey",
    in: "query",
    name,
});
const depictHeaderSecurity = ({ name }) => ({
    type: "apiKey",
    in: "header",
    name,
});
const depictCookieSecurity = ({ name }) => ({
    type: "apiKey",
    in: "cookie",
    name,
});
const depictOpenIdSecurity = ({ url: openIdConnectUrl, }) => ({
    type: "openIdConnect",
    openIdConnectUrl,
});
const depictOAuth2Security = ({ flows = {} }) => ({
    type: "oauth2",
    flows: Object.keys(flows).reduce((acc, key) => {
        const flow = flows[key];
        if (!flow) {
            return acc;
        }
        const { scopes = {}, ...rest } = flow;
        return { ...acc, [key]: { ...rest, scopes } };
    }, {}),
});
const depictSecurity = (container) => {
    const methods = {
        basic: depictBasicSecurity,
        bearer: depictBearerSecurity,
        input: depictInputSecurity,
        header: depictHeaderSecurity,
        cookie: depictCookieSecurity,
        openid: depictOpenIdSecurity,
        oauth2: depictOAuth2Security,
    };
    return (0, logical_container_1.mapLogicalContainer)(container, (security) => methods[security.type](security));
};
exports.depictSecurity = depictSecurity;
const depictSecurityRefs = (container) => {
    if (typeof container === "object") {
        if ("or" in container) {
            return container.or.map((entry) => ("and" in entry
                ? entry.and
                : [entry]).reduce((agg, { name, scopes }) => ({
                ...agg,
                [name]: scopes,
            }), {}));
        }
        if ("and" in container) {
            return (0, exports.depictSecurityRefs)((0, logical_container_1.andToOr)(container));
        }
    }
    return (0, exports.depictSecurityRefs)({ or: [container] });
};
exports.depictSecurityRefs = depictSecurityRefs;
const depictRequest = ({ method, path, endpoint, }) => {
    const pathParams = (0, common_helpers_1.getRoutePathParams)(path);
    const bodyDepiction = (0, exports.excludeExampleFromDepiction)((0, exports.excludeParamsFromDepiction)((0, exports.depictSchema)({
        schema: endpoint.getInputSchema(),
        isResponse: false,
    }), pathParams));
    const bodyExamples = (0, exports.depictIOExamples)(endpoint.getInputSchema(), false, pathParams);
    return {
        content: endpoint.getInputMimeTypes().reduce((carry, mimeType) => ({
            ...carry,
            [mimeType]: {
                schema: {
                    description: `${method.toUpperCase()} ${path} request body`,
                    ...bodyDepiction,
                },
                ...bodyExamples,
            },
        }), {}),
    };
};
exports.depictRequest = depictRequest;
const depictTags = (tags) => Object.keys(tags).map((tag) => {
    const def = tags[tag];
    return {
        name: tag,
        description: typeof def === "string" ? def : def.description,
        ...(typeof def === "object" && def.url
            ? { externalDocs: { url: def.url } }
            : {}),
    };
});
exports.depictTags = depictTags;
const ensureShortDescription = (description) => {
    if (description.length <= shortDescriptionLimit) {
        return description;
    }
    return description.slice(0, shortDescriptionLimit - 1) + "…";
};
exports.ensureShortDescription = ensureShortDescription;
//# sourceMappingURL=open-api-helpers.js.map