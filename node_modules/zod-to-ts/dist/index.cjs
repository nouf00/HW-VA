"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};

// src/index.ts
var _typescript = require('typescript'); var _typescript2 = _interopRequireDefault(_typescript);

// src/utils.ts

var { factory: f } = _typescript2.default;
var maybeIdentifierToTypeReference = (identifier) => {
  if (_typescript2.default.isIdentifier(identifier)) {
    return f.createTypeReferenceNode(identifier);
  }
  return identifier;
};
var createTypeReferenceFromString = (identifier) => f.createTypeReferenceNode(f.createIdentifier(identifier));
var createUnknownKeywordNode = () => f.createKeywordTypeNode(_typescript2.default.SyntaxKind.UnknownKeyword);
var createTypeAlias = (node, identifier, comment) => {
  const typeAlias = f.createTypeAliasDeclaration(void 0, void 0, f.createIdentifier(identifier), void 0, node);
  if (comment) {
    addJsDocComment(typeAlias, comment);
  }
  return typeAlias;
};
var printNode = (node, printerOptions) => {
  const sourceFile = _typescript2.default.createSourceFile("print.ts", "", _typescript2.default.ScriptTarget.Latest, false, _typescript2.default.ScriptKind.TS);
  const printer = _typescript2.default.createPrinter(printerOptions);
  return printer.printNode(_typescript2.default.EmitHint.Unspecified, node, sourceFile);
};
var withGetType = (schema, getType) => {
  schema.getType = getType;
  return schema;
};
var identifierRE = /^[A-Za-z_$][A-Za-z0-9_$]*$/;
var getIdentifierOrStringLiteral = (str) => {
  if (identifierRE.test(str)) {
    return f.createIdentifier(str);
  }
  return f.createStringLiteral(str);
};
var addJsDocComment = (node, text) => {
  _typescript2.default.addSyntheticLeadingComment(node, _typescript2.default.SyntaxKind.MultiLineCommentTrivia, `* ${text} `, true);
};

// src/index.ts
var { factory: f2 } = _typescript2.default;
var callGetType = (zod, identifier, options) => {
  let type = null;
  if (zod.getType)
    type = zod.getType(_typescript2.default, identifier, options);
  return type;
};
var resolveOptions = (raw) => {
  const resolved = { resolveNativeEnums: true };
  return __spreadValues(__spreadValues({}, resolved), raw);
};
var zodToTs = (zod, identifier, options) => {
  const resolvedIdentifier = identifier != null ? identifier : "Identifier";
  const resolvedOptions = resolveOptions(options);
  const store = { nativeEnums: [] };
  const node = zodToTsNode(zod, resolvedIdentifier, store, resolvedOptions);
  return { node, store };
};
var zodToTsNode = (zod, identifier, store, options) => {
  const { typeName } = zod._def;
  const getTypeType = callGetType(zod, identifier, options);
  if (getTypeType && typeName !== "ZodNativeEnum") {
    return maybeIdentifierToTypeReference(getTypeType);
  }
  const otherArgs = [identifier, store, options];
  switch (typeName) {
    case "ZodString":
      return f2.createKeywordTypeNode(_typescript2.default.SyntaxKind.StringKeyword);
    case "ZodNumber":
      return f2.createKeywordTypeNode(_typescript2.default.SyntaxKind.NumberKeyword);
    case "ZodBigInt":
      return f2.createKeywordTypeNode(_typescript2.default.SyntaxKind.BigIntKeyword);
    case "ZodBoolean":
      return f2.createKeywordTypeNode(_typescript2.default.SyntaxKind.BooleanKeyword);
    case "ZodDate":
      return f2.createTypeReferenceNode(f2.createIdentifier("Date"));
    case "ZodUndefined":
      return f2.createKeywordTypeNode(_typescript2.default.SyntaxKind.UndefinedKeyword);
    case "ZodNull":
      return f2.createLiteralTypeNode(f2.createNull());
    case "ZodVoid":
      return f2.createUnionTypeNode([
        f2.createKeywordTypeNode(_typescript2.default.SyntaxKind.VoidKeyword),
        f2.createKeywordTypeNode(_typescript2.default.SyntaxKind.UndefinedKeyword)
      ]);
    case "ZodAny":
      return f2.createKeywordTypeNode(_typescript2.default.SyntaxKind.AnyKeyword);
    case "ZodUnknown":
      return createUnknownKeywordNode();
    case "ZodNever":
      return f2.createKeywordTypeNode(_typescript2.default.SyntaxKind.NeverKeyword);
    case "ZodLazy": {
      if (!getTypeType)
        return createTypeReferenceFromString(identifier);
      break;
    }
    case "ZodLiteral": {
      let literal;
      const literalValue = zod._def.value;
      switch (typeof literalValue) {
        case "number":
          literal = f2.createNumericLiteral(literalValue);
          break;
        case "boolean":
          if (literalValue === true)
            literal = f2.createTrue();
          else
            literal = f2.createFalse();
          break;
        default:
          literal = f2.createStringLiteral(literalValue);
          break;
      }
      return f2.createLiteralTypeNode(literal);
    }
    case "ZodObject": {
      const properties = Object.entries(zod._def.shape());
      const members = properties.map(([key, value]) => {
        const nextZodNode = value;
        const type = zodToTsNode(nextZodNode, ...otherArgs);
        const { typeName: nextZodNodeTypeName } = nextZodNode._def;
        const isOptional = nextZodNodeTypeName === "ZodOptional" || nextZodNode.isOptional();
        const propertySignature = f2.createPropertySignature(void 0, getIdentifierOrStringLiteral(key), isOptional ? f2.createToken(_typescript2.default.SyntaxKind.QuestionToken) : void 0, type);
        if (nextZodNode.description) {
          addJsDocComment(propertySignature, nextZodNode.description);
        }
        return propertySignature;
      });
      return f2.createTypeLiteralNode(members);
    }
    case "ZodArray": {
      const type = zodToTsNode(zod._def.type, ...otherArgs);
      const node = f2.createArrayTypeNode(type);
      return node;
    }
    case "ZodEnum": {
      const types = zod._def.values.map((value) => f2.createStringLiteral(value));
      return f2.createUnionTypeNode(types);
    }
    case "ZodUnion": {
      const types = zod._def.options.map((option) => zodToTsNode(option, ...otherArgs));
      return f2.createUnionTypeNode(types);
    }
    case "ZodEffects": {
      const node = zodToTsNode(zod._def.schema, ...otherArgs);
      return node;
    }
    case "ZodNativeEnum": {
      let type = getTypeType;
      if (!type)
        return createUnknownKeywordNode();
      if (options.resolveNativeEnums) {
        const enumMembers = Object.entries(zod._def.values).map(([key, value]) => {
          const literal = typeof value === "number" ? f2.createNumericLiteral(value) : f2.createStringLiteral(value);
          return f2.createEnumMember(getIdentifierOrStringLiteral(key), literal);
        });
        if (_typescript2.default.isIdentifier(type)) {
          store.nativeEnums.push(f2.createEnumDeclaration(void 0, void 0, type, enumMembers));
        } else {
          throw new Error("getType on nativeEnum must return an identifier when resolveNativeEnums is set");
        }
      }
      type = maybeIdentifierToTypeReference(type);
      return type;
    }
    case "ZodOptional": {
      const innerType = zodToTsNode(zod._def.innerType, ...otherArgs);
      return f2.createUnionTypeNode([
        innerType,
        f2.createKeywordTypeNode(_typescript2.default.SyntaxKind.UndefinedKeyword)
      ]);
    }
    case "ZodNullable": {
      const innerType = zodToTsNode(zod._def.innerType, ...otherArgs);
      return f2.createUnionTypeNode([
        innerType,
        f2.createLiteralTypeNode(f2.createNull())
      ]);
    }
    case "ZodTuple": {
      const types = zod._def.items.map((option) => zodToTsNode(option, ...otherArgs));
      return f2.createTupleTypeNode(types);
    }
    case "ZodRecord": {
      const valueType = zodToTsNode(zod._def.valueType, ...otherArgs);
      const node = f2.createTypeLiteralNode([f2.createIndexSignature(void 0, void 0, [f2.createParameterDeclaration(void 0, void 0, void 0, f2.createIdentifier("x"), void 0, f2.createKeywordTypeNode(_typescript2.default.SyntaxKind.StringKeyword), void 0)], valueType)]);
      return node;
    }
    case "ZodMap": {
      const valueType = zodToTsNode(zod._def.valueType, ...otherArgs);
      const keyType = zodToTsNode(zod._def.keyType, ...otherArgs);
      const node = f2.createTypeReferenceNode(f2.createIdentifier("Map"), [
        keyType,
        valueType
      ]);
      return node;
    }
    case "ZodSet": {
      const type = zodToTsNode(zod._def.valueType, ...otherArgs);
      const node = f2.createTypeReferenceNode(f2.createIdentifier("Set"), [type]);
      return node;
    }
    case "ZodIntersection": {
      const left = zodToTsNode(zod._def.left, ...otherArgs);
      const right = zodToTsNode(zod._def.right, ...otherArgs);
      const node = f2.createIntersectionTypeNode([left, right]);
      return node;
    }
    case "ZodPromise": {
      const type = zodToTsNode(zod._def.type, ...otherArgs);
      const node = f2.createTypeReferenceNode(f2.createIdentifier("Promise"), [type]);
      return node;
    }
    case "ZodFunction": {
      const argTypes = zod._def.args._def.items.map((arg, index) => {
        const argType = zodToTsNode(arg, ...otherArgs);
        return f2.createParameterDeclaration(void 0, void 0, void 0, f2.createIdentifier(`args_${index}`), void 0, argType, void 0);
      });
      argTypes.push(f2.createParameterDeclaration(void 0, void 0, f2.createToken(_typescript2.default.SyntaxKind.DotDotDotToken), f2.createIdentifier(`args_${argTypes.length}`), void 0, f2.createArrayTypeNode(createUnknownKeywordNode()), void 0));
      const returnType = zodToTsNode(zod._def.returns, ...otherArgs);
      const node = f2.createFunctionTypeNode(void 0, argTypes, returnType);
      return node;
    }
    case "ZodDefault": {
      const type = zodToTsNode(zod._def.innerType, ...otherArgs);
      const filteredNodes = [];
      type.forEachChild((node) => {
        if (![_typescript2.default.SyntaxKind.UndefinedKeyword].includes(node.kind)) {
          filteredNodes.push(node);
        }
      });
      type.types = filteredNodes;
      return type;
    }
  }
  return f2.createKeywordTypeNode(_typescript2.default.SyntaxKind.AnyKeyword);
};






exports.createTypeAlias = createTypeAlias; exports.printNode = printNode; exports.resolveOptions = resolveOptions; exports.withGetType = withGetType; exports.zodToTs = zodToTs;
